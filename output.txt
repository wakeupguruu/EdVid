{
    "output": "```json\n[\n  {\n    \"scene\": \"Scene 1: The Ancient Discovery - Introduction to the Pythagorean Theorem\",\n    \"code\": \"from manimlib import *\\n\\nclass PythagoreanIntro(Scene):\\n    def construct(self):\\n        # Set up cinematic camera\\n        self.camera.frame.save_state()\\n        \\n        # Title sequence with dramatic reveal\\n        title = Text(\\\"The Pythagorean Theorem\\\", font_size=72)\\n        subtitle = Text(\\\"A 2500-Year Journey\\\", font_size=36, color=GREY_B)\\n        subtitle.next_to(title, DOWN, buff=0.5)\\n        \\n        # Ancient Greek pattern background\\n        pattern = VGroup()\\n        for i in range(-8, 9):\\n            for j in range(-5, 6):\\n                if (i + j) % 2 == 0:\\n                    square = Square(side_length=0.3, fill_opacity=0.1, color=GOLD_E)\\n                    square.move_to([i * 0.3, j * 0.3, 0])\\n                    pattern.add(square)\\n        \\n        # Animate entrance\\n        self.play(\\n            FadeIn(pattern, lag_ratio=0.01),\\n            run_time=2\\n        )\\n        self.play(\\n            Write(title),\\n            FadeIn(subtitle, shift=UP),\\n            run_time=3\\n        )\\n        self.wait(2)\\n        \\n        # Fade to theorem statement\\n        self.play(\\n            FadeOut(VGroup(title, subtitle)),\\n            pattern.animate.set_opacity(0.05),\\n            run_time=2\\n        )\\n        \\n        # The famous equation\\n        equation = Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=96)\\n        equation.set_color_by_gradient(BLUE, GREEN)\\n        \\n        # Create right triangle\\n        triangle = Polygon(\\n            [-3, -2, 0], [3, -2, 0], [3, 2, 0],\\n            color=WHITE, stroke_width=4\\n        )\\n        \\n        # Label sides\\n        label_a = Tex(\\\"a\\\", font_size=48, color=BLUE)\\n        label_b = Tex(\\\"b\\\", font_size=48, color=GREEN)\\n        label_c = Tex(\\\"c\\\", font_size=48, color=RED)\\n        \\n        label_a.next_to(triangle.get_edge_center(LEFT), LEFT)\\n        label_b.next_to(triangle.get_edge_center(DOWN), DOWN)\\n        label_c.move_to(triangle.get_center() + [-0.5, -0.5, 0])\\n        \\n        # Right angle indicator\\n        right_angle = Square(side_length=0.4, color=YELLOW)\\n        right_angle.move_to(triangle.get_vertices()[1] + [0.2, 0.2, 0])\\n        \\n        # Cinematic reveal\\n        self.play(\\n            equation.animate.scale(0.6).to_edge(UP),\\n            run_time=2\\n        )\\n        self.play(\\n            Create(triangle),\\n            run_time=2\\n        )\\n        self.play(\\n            FadeIn(right_angle),\\n            Write(label_a),\\n            Write(label_b), \\n            Write(label_c),\\n            run_time=2\\n        )\\n        \\n        # Camera zoom effect\\n        self.play(\\n            self.camera.frame.animate.scale(0.8).move_to(triangle),\\n            run_time=2\\n        )\\n        self.wait(2)\\n        \\n        # Transition text\\n        discovery_text = Text(\\\"But what does this really mean?\\\", font_size=36, color=GREY_A)\\n        discovery_text.to_edge(DOWN)\\n        \\n        self.play(\\n            FadeIn(discovery_text, shift=UP),\\n            run_time=2\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 2: Visual Proof - The Square Construction\",\n    \"code\": \"from manimlib import *\\n\\nclass SquareConstruction(Scene):\\n    def construct(self):\\n        # Create base right triangle\\n        vertices = [[-2, -1.5, 0], [2, -1.5, 0], [2, 1.5, 0]]\\n        triangle = Polygon(*vertices, color=WHITE, stroke_width=3)\\n        \\n        # Calculate side lengths\\n        a = np.linalg.norm(np.array(vertices[2]) - np.array(vertices[1]))\\n        b = np.linalg.norm(np.array(vertices[1]) - np.array(vertices[0]))\\n        c = np.linalg.norm(np.array(vertices[2]) - np.array(vertices[0]))\\n        \\n        # Create squares on each side\\n        # Square on side a (vertical)\\n        square_a = Square(side_length=a, color=BLUE, fill_opacity=0.3)\\n        square_a.move_to(vertices[1] + [a/2 + 0.1, 0, 0])\\n        \\n        # Square on side b (horizontal)\\n        square_b = Square(side_length=b, color=GREEN, fill_opacity=0.3)\\n        square_b.move_to(vertices[0] + [0, -b/2 - 0.1, 0])\\n        \\n        # Square on hypotenuse c\\n        angle = np.arctan2(vertices[2][1] - vertices[0][1], vertices[2][0] - vertices[0][0])\\n        square_c = Square(side_length=c, color=RED, fill_opacity=0.3)\\n        square_c.rotate(angle - PI/2)\\n        mid_point = (np.array(vertices[0]) + np.array(vertices[2])) / 2\\n        offset = np.array([np.sin(angle), -np.cos(angle), 0]) * c/2\\n        square_c.move_to(mid_point + offset * 1.1)\\n        \\n        # Labels for areas\\n        area_a = Tex(r\\\"a^2\\\", font_size=48, color=BLUE)\\n        area_b = Tex(r\\\"b^2\\\", font_size=48, color=GREEN)\\n        area_c = Tex(r\\\"c^2\\\", font_size=48, color=RED)\\n        \\n        area_a.move_to(square_a.get_center())\\n        area_b.move_to(square_b.get_center())\\n        area_c.move_to(square_c.get_center())\\n        \\n        # Title\\n        title = Text(\\\"Geometric Proof\\\", font_size=56)\\n        title.to_edge(UP)\\n        \\n        # Animate construction\\n        self.play(Write(title), run_time=2)\\n        self.play(Create(triangle), run_time=2)\\n        \\n        # Dramatic square reveals\\n        self.play(\\n            GrowFromCenter(square_a),\\n            Write(area_a),\\n            run_time=2\\n        )\\n        self.play(\\n            GrowFromCenter(square_b),\\n            Write(area_b),\\n            run_time=2\\n        )\\n        self.play(\\n            GrowFromCenter(square_c),\\n            Write(area_c),\\n            run_time=2\\n        )\\n        \\n        # Show the equation\\n        equation = Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=64)\\n        equation.to_edge(DOWN)\\n        equation.set_color_by_tex_to_color_map({\\n            \\\"a^2\\\": BLUE,\\n            \\\"b^2\\\": GREEN,\\n            \\\"c^2\\\": RED\\n        })\\n        \\n        # Camera focus on equation\\n        self.play(\\n            Write(equation),\\n            self.camera.frame.animate.shift(DOWN * 0.5),\\n            run_time=3\\n        )\\n        \\n        # Visual emphasis with pulsing\\n        self.play(\\n            square_a.animate.set_fill_opacity(0.6),\\n            square_b.animate.set_fill_opacity(0.6),\\n            run_time=1\\n        )\\n        self.play(\\n            square_a.animate.set_fill_opacity(0.3),\\n            square_b.animate.set_fill_opacity(0.3),\\n            square_c.animate.set_fill_opacity(0.6),\\n            run_time=1\\n        )\\n        self.wait(2)\"\n  },\n  .................... \\n            sphere_eq.animate.next_to(ORIGIN, DOWN, buff=2.5),\\n            run_time=2\\n        )\\n        \\n        # Add geodesics\\n        geodesic_text = Text(\\\"On a sphere, 'straight lines' are great circles\\\", font_size=32, color=GREY_A)\\n        geodesic_text.to_edge(UP, buff=1.5)\\n        \\n        self.play(Write(geodesic_text), run_time=2)\\n        \\n        # Show angle sum > 180°\\n        angle_sum = Tex(r\\\"\\\\text{Angle sum} > 180°\\\", font_size=36, color=YELLOW)\\n        angle_sum.next_to(sphere_eq, DOWN, buff=0.5)\\n        \\n        # Mark angles\\n        angle_markers = VGroup()\\n        for vertex in sphere_tri.get_vertices()[:3]:\\n            arc = Arc(radius=0.3, angle=PI/3, color=YELLOW)\\n            arc.move_to(vertex)\\n            angle_markers.add(arc)\\n        \\n        self.play(\\n            Create(angle_markers),\\n            Write(angle_sum),\\n            run_time=3\\n        )\\n        \\n        # Final insight\\n        insight = Text(\\n            \\\"The Pythagorean theorem reveals\\\\nthe curvature of space itself!\\\",\\n            font_size=36,\\n            color=GOLD\\n        )\\n        insight.to_edge(DOWN, buff=0.5)\\n        \\n        self.play(\\n            Write(insight),\\n            sphere_surface.animate.set_fill_opacity(0.4),\\n            run_time=3\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 10: Historical Timeline and Impact\",\n    \"code\": \"from manimlib import *\\n\\nclass HistoricalTimeline(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"The Pythagorean Legacy\\\", font_size=56)\\n        subtitle = Text(\\\"2500 Years of Mathematical Impact\\\", font_size=32, color=GREY_B)\\n        title_group = VGroup(title, subtitle).arrange(DOWN, buff=0.3)\\n        title_group.to_edge(UP)\\n        \\n        self.play(\\n            Write(title),\\n            FadeIn(subtitle, shift=UP),\\n            run_time=3\\n        )\\n        \\n        # Timeline\\n        timeline = Line(LEFT * 6, RIGHT * 6, stroke_width=4, color=GREY_C)\\n        timeline.shift(UP * 0.5)\\n        \\n        # Time markers\\n        dates = [-500, 300, 1600, 1900, 2024]\\n        events = [\\n            \\\"Pythagoras\\\\n~500 BCE\\\",\\n            \\\"Euclid's Elements\\\\n~300 BCE\\\",\\n            \\\"Descartes\\\\nCoordinate Geometry\\\\n1637 CE\\\",\\n            \\\"Einstein\\\\nSpacetime\\\\n1905 CE\\\",\\n            \\\"Modern Applications\\\\n2024 CE\\\"\\n        ]\\n        \\n        markers = VGroup()\\n        labels = VGroup()\\n        \\n        for date, event in zip(dates, events):\\n            # Normalize position\\n            x_pos = (date + 500) / 2524 * 12 - 6\\n            \\n            # Create marker\\n            marker = Line(UP * 0.2, DOWN * 0.2, stroke_width=3, color=WHITE)\\n            marker.move_to([x_pos, 0.5, 0])\\n            markers.add(marker)\\n            \\n            # Create label\\n            label = Text(event, font_size=20, color=GREY_A)\\n            label.next_to(marker, DOWN, buff=0.3)\\n            labels.add(label)\\n        \\n        # Animate timeline\\n        self.play(Create(timeline), run_time=2)\\n        self.play(\\n            *[Create(marker) for marker in markers],\\n            run_time=2\\n        )\\n        self.play(\\n            *[FadeIn(label, shift=UP) for label in labels],\\n            run_time=3\\n        )\\n        \\n        # Highlight key developments\\n        self.wait(1)\\n        \\n        # Pythagoras highlight\\n        pythagoras_rect = SurroundingRectangle(labels[0], color=GOLD, buff=0.1)\\n        pyth_detail = VGroup(\\n            Text(\\\"The Original Discovery\\\", font_size=28, color=GOLD),\\n            Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=36)\\n        ).arrange(DOWN, buff=0.3)\\n        pyth_detail.to_edge(DOWN, buff=1)\\n        \\n        self.play(\\n            Create(pythagoras_rect),\\n            FadeIn(pyth_detail, shift=UP),\\n            run_time=2\\n        )\\n        self.wait(1)\\n        self.play(\\n            FadeOut(pythagoras_rect),\\n            FadeOut(pyth_detail),\\n            run_time=1\\n        )\\n        \\n        # Euclid highlight\\n        euclid_rect = SurroundingRectangle(labels[1], color=BLUE, buff=0.1)\\n        euclid_detail = VGroup(\\n            Text(\\\"Rigorous Proof\\\", font_size=28, color=BLUE),\\n            Text(\\\"47th Proposition, Book I\\\", font_size=24, color=GREY_B)\\n        ).arrange(DOWN, buff=0.3)\\n        euclid_detail.to_edge(DOWN, buff=1)\\n        \\n        self.play(\\n            Create(euclid_rect),\\n            FadeIn(euclid_detail, shift=UP),\\n            run_time=2\\n        )\\n        self.wait(1)\\n        self.play(\\n            FadeOut(euclid_rect),\\n            FadeOut(euclid_detail),\\n            run_time=1\\n        )\\n        \\n        # Modern applications montage\\n        self.play(\\n            FadeOut(VGroup(timeline, markers, labels)),\\n            run_time=2\\n        )\\n        \\n        # Application grid\\n        applications = [\\n            (\\\"Computer Graphics\\\", BLUE, \\\"3D rendering, game engines\\\"),\\n            (\\\"GPS Navigation\\\", GREEN, \\\"Distance calculations\\\"),\\n            (\\\"Architecture\\\", ORANGE, \\\"Structural engineering\\\"),\\n            (\\\"Signal Processing\\\", PURPLE, \\\"Fourier transforms\\\"),\\n            (\\\"Machine Learning\\\", RED, \\\"Euclidean distance metrics\\\"),\\n            (\\\"Quantum Physics\\\", TEAL, \\\"Wave functions\\\")\\n        ]\\n        \\n        app_groups = VGroup()\\n        for i, (title, color, desc) in enumerate(applications):\\n            # Create application box\\n            box = Rectangle(width=3.5, height=1.5, color=color, fill_opacity=0.2)\\n            app_title = Text(title, font_size=24, color=color)\\n            app_desc = Text(desc, font_size=16, color=GREY_B)\\n            \\n            app_group = VGroup(box, app_title, app_desc)\\n            app_title.move_to(box.get_top() + DOWN * 0.3)\\n            app_desc.move_to(box.get_bottom() + UP * 0.3)\\n            \\n            # Position in grid\\n            row = i // 3\\n            col = i % 3\\n            app_group.move_to([col * 4 - 4, -row * 2, 0])\\n            app_groups.add(app_group)\\n        \\n        # Animate applications\\n        self.play(\\n            *[FadeIn(app, scale=0.8) for app in app_groups],\\n            run_time=3\\n        )\\n        \\n        # Pulsing emphasis\\n        for app in app_groups:\\n            self.play(\\n                app[0].animate.set_fill_opacity(0.4),\\n                run_time=0.3\\n            )\\n            self.play(\\n                app[0].animate.set_fill_opacity(0.2),\\n                run_time=0.3\\n            )\\n        \\n        # Final message\\n        final_message = VGroup(\\n            Text(\\\"The Pythagorean Theorem:\\\", font_size=40),\\n            Text(\\\"A cornerstone of human knowledge\\\", font_size=36, color=GOLD)\\n        ).arrange(DOWN, buff=0.4)\\n        final_message.to_edge(DOWN, buff=0.5)\\n        \\n        # Background fade\\n        bg_rect = Rectangle(\\n            width=14, height=2,\\n            fill_opacity=0.8,\\n            fill_color=BLACK,\\n            stroke_width=0\\n        )\\n        bg_rect.move_to(final_message)\\n        \\n        self.play(\\n            FadeIn(bg_rect),\\n            Write(final_message),\\n            run_time=3\\n        )\\n        \\n        # Final equation fade in\\n        final_eq = Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=96)\\n        final_eq.set_color_by_gradient(BLUE, GREEN, RED)\\n        final_eq.move_to(ORIGIN)\\n        \\n        self.play(\\n            FadeOut(app_groups),\\n            FadeOut(bg_rect),\\n            FadeOut(final_message[0]),\\n            Transform(final_message[1], final_eq),\\n            run_time=4\\n        )\\n        self.wait(3)\"\n  }\n]\n```"
}