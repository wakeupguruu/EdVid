import { promises as fs } from 'fs';
import path from 'path';

// Your raw LLM output as a JS object
const raw = {
    "output": "[\n  {\n    \"scene\": \"Scene 1: Title Introduction\",\n    \"code\": \"\"\"\nclass PythagoreanTitle(Scene):\n    def construct(self):\n        title = Text(\"The Pythagorean Theorem\", font_size=60)\n        subtitle = Text(\"The Fundamental Bridge Between Geometry and Numbers\", font_size=36)\n        subtitle.set_color(BLUE)\n        subtitle.next_to(title, DOWN)\n        \n        # Fade in with camera movement\n        self.camera.frame.set_euler_angles(theta=30*DEGREES)\n        self.play(\n            Write(title),\n            self.camera.frame.animate.set_euler_angles(theta=0*DEGREES),\n            run_time=2\n        )\n        self.play(FadeIn(subtitle, shift=UP))\n        self.wait()\n\"\"\",\n    \"text\": \"The Pythagorean Theorem - one of mathematics' most beautiful and fundamental relationships. This elegant equation has shaped our understanding of geometry for over two thousand years.\"\n  },\n  {\n    \"scene\": \"Scene 2: Basic Right Triangle\",\n    \"code\": \"\"\"\nclass RightTriangle(Scene):\n    def construct(self):\n        # Create right triangle\n        triangle = Polygon(\n            ORIGIN, RIGHT*4, UP*3,\n            color=WHITE, fill_opacity=0.2\n        )\n        right_angle = RightAngle(\n            Line(ORIGIN, RIGHT*4),\n            Line(ORIGIN, UP*3),\n            length=0.4\n        )\n        \n        # Labels\n        a = MathTex(\"a\")\n        b = MathTex(\"b\")\n        c = MathTex(\"c\")\n        \n        a.next_to(triangle, RIGHT)\n        b.next_to(triangle, UP)\n        c.next_to(triangle.get_center(), DOWN+RIGHT)\n        \n        # Animate\n        self.play(Create(triangle))\n        self.play(Create(right_angle))\n        self.play(\n            Write(a),\n            Write(b),\n            Write(c)\n        )\n        self.wait()\n\"\"\",\n    \"text\": \"Let's start with a simple right triangle. The two sides that form the right angle are called the legs, which we'll label 'a' and 'b'. The longest side, opposite to the right angle, is called the hypotenuse, labeled 'c'.\"\n  },\n  {\n    \"scene\": \"Scene 3: The Formula\",\n    \"code\": \"\"\"\nclass PythagoreanFormula(Scene):\n    def construct(self):\n        formula = MathTex(\n            \"a^2 + b^2 = c^2\",\n            font_size=72\n        )\n        \n        # Create spotlight effect\n        spotlight = Circle(radius=2)\n        spotlight.set_fill(WHITE, opacity=0.2)\n        spotlight.set_stroke(WHITE, opacity=0)\n        \n        # Animate with camera movement\n        self.camera.frame.set_z(5)\n        self.play(\n            Write(formula),\n            self.camera.frame.animate.set_z(0),\n            FadeIn(spotlight),\n            run_time=2\n        )\n        self.play(\n            spotlight.animate.scale(1.5),\n            formula.animate.set_color(YELLOW)\n        )\n        self.wait()\n\"\"\",\n    \"text\": \"The Pythagorean theorem states that in any right triangle, the square of the hypotenuse equals the sum of squares of the other two sides. In mathematical terms: a² + b² = c². This simple equation connects geometry and algebra in a profound way.\"\n  },\n  {\n    \"scene\": \"Scene 4: Square Visualization\",\n    \"code\": \"\"\"\nclass SquareVisualization(Scene):\n    def construct(self):\n        # Create triangle\n        triangle = Polygon(ORIGIN, RIGHT*3, UP*4)\n        \n        # Create squares on each side\n        square_a = Square(side_length=3)\n        square_b = Square(side_length=4)\n        square_c = Square(side_length=5)\n        \n        # Position squares\n        square_a.next_to(triangle, RIGHT, buff=0)\n        square_b.next_to(triangle, UP, buff=0)\n        square_c.rotate(angle=math.atan(4/3))\n        square_c.move_to(triangle.get_center())\n        \n        # Colors\n        square_a.set_fill(RED, opacity=0.5)\n        square_b.set_fill(BLUE, opacity=0.5)\n        square_c.set_fill(GREEN, opacity=0.5)\n        \n        # Animate with camera movement\n        self.camera.frame.scale(1.5)\n        self.play(Create(triangle))\n        self.play(\n            Create(square_a),\n            Create(square_b),\n            Create(square_c)\n        )\n        \n        # Add area labels\n        areas = VGroup(\n            MathTex(\"9\"),\n            MathTex(\"16\"),\n            MathTex(\"25\")\n        )\n        areas[0].move_to(square_a.get_center())\n        areas[1].move_to(square_b.get_center())\n        areas[2].move_to(square_c.get_center())\n        \n        self.play(Write(areas))\n        self.wait()\n\"\"\",\n    \"text\": \"Let's visualize what this means geometrically. If we draw squares on each side of our triangle, the areas of these squares demonstrate the theorem perfectly. For a 3-4-5 triangle, the squares have areas of 9, 16, and 25 square units respectively. Notice how 9 plus 16 equals 25!\"\n  },\n  {\n    \"scene\": \"Scene 5: Dynamic Proof\",\n    \"code\": \"\"\"\nclass DynamicProof(Scene):\n    def construct(self):\n        def create_triangle(theta):\n            a = 3\n            b = 4\n            c = math.sqrt(a**2 + b**2)\n            triangle = Polygon(\n                ORIGIN,\n                RIGHT*a,\n                RIGHT*a + rotate_vector(UP*b, theta)\n            )\n            return triangle\n        \n        # Create initial triangle\n        triangle = create_triangle(0)\n        angle_tracker = ValueTracker(0)\n        \n        # Make triangle dynamic\n        triangle.add_updater(\n            lambda m: m.become(create_triangle(angle_tracker.get_value()))\n        )\n        \n        # Add angle measure\n        angle = always_redraw(\n            lambda: Angle(\n                Line(ORIGIN, RIGHT*3),\n                Line(ORIGIN, RIGHT*3 + rotate_vector(UP*4, angle_tracker.get_value())),\n                radius=0.5\n            )\n        )\n        \n        self.play(Create(triangle), Create(angle))\n        self.play(\n            angle_tracker.animate.set_value(PI/2),\n            run_time=3\n        )\n        self.wait()\n\"\"\",\n    \"text\": \"Watch as we rotate one leg of our triangle. Notice that only when the angle is exactly 90 degrees does the Pythagorean theorem hold true. This is what makes right triangles special - they're the only triangles where this perfect square relationship exists.\"\n  },\n  {\n    \"scene\": \"Scene 6: Real World Applications\",\n    \"code\": \"\"\"\nclass RealWorldApplications(Scene):\n    def construct(self):\n        # Create construction worker scene\n        building = Rectangle(height=4, width=3)\n        ladder = Line(ORIGIN, UP*4 + RIGHT*3)\n        ground = Line(LEFT*5, RIGHT*5)\n        \n        # Add measurements\n        height = BraceBetweenPoints(ORIGIN, UP*4)\n        width = BraceBetweenPoints(ORIGIN, RIGHT*3)\n        length = BraceBetweenPoints(RIGHT*3, UP*4 + RIGHT*3)\n        \n        height_label = MathTex(\"4\\\\text{ m}\")\n        width_label = MathTex(\"3\\\\text{ m}\")\n        length_label = MathTex(\"5\\\\text{ m}\")\n        \n        height_label.next_to(height, LEFT)\n        width_label.next_to(width, DOWN)\n        length_label.next_to(ladder.get_center(), UP)\n        \n        group = VGroup(building, ladder, ground, height, width, length,\n                      height_label, width_label, length_label)\n        \n        # Camera movement\n        self.camera.frame.set_euler_angles(phi=50*DEGREES, theta=30*DEGREES)\n        self.play(Create(group))\n        self.play(\n            self.camera.frame.animate.set_euler_angles(phi=20*DEGREES, theta=-20*DEGREES),\n            run_time=3\n        )\n        self.wait()\n\"\"\",\n    \"text\": \"The Pythagorean theorem has countless practical applications. Imagine a construction worker placing a ladder against a wall. If the wall is 4 meters high and the ladder's base must be 3 meters from the wall, the ladder needs to be 5 meters long to reach the top safely.\"\n  },\n  {\n    \"scene\": \"Scene 7: Fractal Exploration\",\n    \"code\": \"\"\"\nclass PythagoreanFractal(Scene):\n    def construct(self):\n        def create_pythagoras_tree(depth, size, angle, position):\n            if depth == 0:\n                return VGroup()\n            \n            # Create square\n            square = Square(side_length=size)\n            square.move_to(position)\n            \n            # Create branches\n            right_size = size * math.cos(angle)\n            left_size = size * math.sin(angle)\n            \n            right_pos = position + rotate_vector(UP*size + RIGHT*right_size/2, angle)\n            left_pos = position + rotate_vector(UP*size + LEFT*left_size/2, -angle)\n            \n            right_branch = create_pythagoras_tree(depth-1, right_size, angle, right_pos)\n            left_branch = create_pythagoras_tree(depth-1, left_size, angle, left_pos)\n            \n            return VGroup(square, right_branch, left_branch)\n        \n        # Create fractal\n        fractal = create_pythagoras_tree(6, 1, PI/4, ORIGIN)\n        fractal.set_color_by_gradient(BLUE, GREEN, RED)\n        \n        # Animate with camera movement\n        self.camera.frame.scale(2)\n        self.play(\n            Create(fractal),\n            self.camera.frame.animate.scale(0.5).shift(UP),\n            run_time=5\n        )\n        self.wait()\n\"\"\",\n    \"text\": \"The Pythagorean theorem can create beautiful patterns called Pythagorean trees. By repeatedly applying the theorem and creating squares on each new triangle, we generate an infinite fractal pattern. Each branch follows the same mathematical relationship, creating a mesmerizing visualization of mathematical recursion.\"\n  },\n  {\n    \"scene\": \"Scene 8: Historical Context\",\n    \"code\": \"\"\"\nclass HistoricalContext(Scene):\n    def construct(self):\n        # Create timeline\n        timeline = NumberLine(\n            x_range=[-600, 2000, 200],\n            length=12,\n            include_numbers=True,\n            label_direction=DOWN\n        )\n        \n        # Add events\n        events = [\n            (\"Pythagoras\\\\(570-495 BC)\", -570),\n            (\"Euclid's\\\\Elements\", -300),\n            (\"Chinese\\\\Proof\", 200),\n            (\"Modern\\\\Era\", 2000)\n        ]\n        \n        dots = VGroup()\n        labels = VGroup()\n        \n        for event, year in events:\n            dot = Dot(timeline.number_to_point(year))\n            label = Text(event, font_size=24)\n            label.next_to(dot, UP)\n            dots.add(dot)\n            labels.add(label)\n        \n        # Animate\n        self.play(Create(timeline))\n        self.play(Create(dots))\n        self.play(Write(labels))\n        \n        # Camera movement\n        self.play(\n            self.camera.frame.animate.shift(UP*0.5).scale(0.8),\n            run_time=2\n        )\n        self.wait()\n\"\"\",\n    \"text\": \"While the theorem bears Pythagoras's name, evidence suggests it was known to ancient Babylonians and Egyptians over a thousand years earlier. Pythagoras and his followers were the first to prove it mathematically around 570 BC. Since then, hundreds of different proofs have been discovered across various cultures and time periods.\"\n  },\n  {\n    \"scene\": \"Scene 9: Three-Dimensional Extension\",\n    \"code\": \"\"\"\nclass ThreeDimensional(ThreeDScene):\n    def construct(self):\n        # Create 3D coordinate system\n        axes = ThreeDAxes()\n        \n        # Create cube\n        cube = Cube(side_length=2)\n        cube.set_fill(BLUE, opacity=0.2)\n        cube.set_stroke(WHITE, opacity=0.5)\n        \n        # Create diagonal line\n        diagonal = Line3D(\n            start=np.array([-1, -1, -1]),\n            end=np.array([1, 1, 1]),\n            color=YELLOW\n        )\n        \n        # Set camera position\n        self.set_camera_orientation(phi=75*DEGREES, theta=30*DEGREES)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        \n        # Animate\n        self.play(Create(axes))\n        self.play(Create(cube))\n        self.play(Create(diagonal))\n        \n        # Add formula\n        formula = MathTex(\"d^2 = a^2 + b^2 + c^2\")\n        formula.to_corner(UR)\n        self.add_fixed_in_frame_mobjects(formula)\n        self.play(Write(formula))\n        \n        self.wait(3)\n        self.stop_ambient_camera_rotation()\n\"\"\",\n    \"text\": \"The Pythagorean theorem extends beautifully into three dimensions. In a cube, the diagonal line from one corner to the opposite corner follows a similar principle: the square of the diagonal equals the sum of squares of the cube's length, width, and height. This relationship is crucial in 3D graphics, engineering, and modern physics.\"\n  },\n  {\n    \"scene\": \"Scene 10: Conclusion\",\n    \"code\": \"\"\"\nclass Conclusion(Scene):\n    def construct(self):\n        # Create final summary\n        summary = VGroup(\n            Text(\"The Pythagorean Theorem:\", font_size=48),\n            MathTex(\"a^2 + b^2 = c^2\", font_size=60),\n            Text(\"A cornerstone of mathematics that connects:\", font_size=36),\n            BulletedList(\n                \"Geometry and Algebra\",\n                \"Ancient and Modern Mathematics\",\n                \"Theory and Practice\",\n                \"Art and Science\"\n            )\n        ).arrange(DOWN, buff=0.5)\n        \n        # Add geometric background\n        triangles = VGroup(*[\n            Triangle(fill_opacity=0.1, fill_color=color)\n            for color in [BLUE, RED, GREEN, YELLOW]\n        ])\n        \n        for i, triangle in enumerate(triangles):\n            triangle.rotate(i * PI/2)\n            triangle.scale(0.5)\n        triangles.arrange_in_grid(2, 2, buff=1)\n        triangles.to_edge(LEFT)\n        \n        # Animate\n        self.camera.frame.scale(1.2)\n        self.play(\n            Create(triangles),\n            Write(summary),\n            run_time=3\n        )\n        \n        # Final camera movement\n        self.play(\n            self.camera.frame.animate.scale(0.8).shift(UP*0.3),\n            run_time=2\n        )\n        self.wait()\n\"\"\",\n    \"text\": \"The Pythagorean theorem represents more than just a mathematical formula - it's a bridge between different branches of mathematics, a tool for practical problem-solving, and a testament to the elegant simplicity that underlies complex mathematical truths. From ancient architecture to modern technology, this fundamental relationship continues to shape our understanding of the world around us.\"\n  }\n]"
};

// Function to robustly parse the LLM output string
function robustParseLLMOutput(rawObj: { output: string }): any[] | null {
  let outputStr = rawObj.output;

  // Replace all code blocks delimited by triple quotes with valid JSON strings
  outputStr = outputStr.replace(/"""([\s\S]*?)"""/g, (match, code) => {
    // Escape backslashes and double quotes, and replace newlines with \\n
    const safe = code
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\r?\n/g, '\\n');
    return `"${safe}"`;
  });

  // Now, parse the string as JSON
  try {
    const parsed = JSON.parse(outputStr);
    return parsed;
  } catch (err) {
    console.error('❌ Error parsing inner output string:', err);
    return null;
  }
}

async function main() {
  const parsedOutput = robustParseLLMOutput(raw);
  if (parsedOutput) {
    const outputPath = path.join(process.cwd(), 'app', 'api', 'output', 'output.json');
    await fs.writeFile(outputPath, JSON.stringify(parsedOutput, null, 2), 'utf-8');
    console.log('✅ Output written to output/output.json');
  } else {
    console.error('❌ Failed to parse LLM output.');
  }
}

main(); 