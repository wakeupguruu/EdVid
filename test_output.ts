import { promises as fs } from 'fs';
import path from 'path';

// Your raw LLM output as a JS object
const raw = {
    "output": "[\n  {\n    \"scene\": \"Scene 1: The Ancient Mystery\",\n    \"code\": \"from manim import *\\n\\nclass AncientMystery(Scene):\\n    def construct(self):\\n        # Create ancient parchment background\\n        bg = Rectangle(width=14, height=8, fill_color=\\\"#F4E4C1\\\", fill_opacity=0.3)\\n        self.add(bg)\\n        \\n        # Title with dramatic entrance\\n        title = Text(\\\"The Pythagorean Theorem\\\", font_size=72, color=GOLD)\\n        subtitle = Text(\\\"An Ancient Discovery That Changed Mathematics\\\", font_size=24, color=GOLD_E)\\n        subtitle.next_to(title, DOWN)\\n        \\n        self.play(Write(title), run_time=3)\\n        self.play(FadeIn(subtitle), run_time=2)\\n        self.wait(2)\\n        \\n        # Fade to historical context\\n        self.play(FadeOut(title), FadeOut(subtitle))\\n        \\n        # Ancient Greek scene\\n        pythagoras = ImageMobject(\\\"pythagoras.png\\\").scale(0.5) if False else Circle(radius=0.5, color=BLUE, fill_opacity=0.8)\\n        pythagoras.to_edge(LEFT)\\n        \\n        date_text = Text(\\\"~570 BCE\\\", font_size=36, color=GOLD_E)\\n        date_text.next_to(pythagoras, UP)\\n        \\n        quote = Text(\\\"'Number rules the universe'\\\", font_size=28, color=WHITE, slant=ITALIC)\\n        quote.next_to(pythagoras, RIGHT, buff=1)\\n        \\n        self.play(FadeIn(pythagoras), Write(date_text))\\n        self.play(Write(quote))\\n        self.wait(2)\\n        \\n        # Transition to theorem\\n        theorem_text = MathTex(r\\\"a^2 + b^2 = c^2\\\", font_size=64, color=YELLOW)\\n        theorem_text.move_to(ORIGIN)\\n        \\n        self.play(\\n            FadeOut(pythagoras), FadeOut(date_text), FadeOut(quote),\\n            Write(theorem_text), run_time=3\\n        )\\n        \\n        # Camera zoom effect\\n        self.play(\\n            self.camera.frame.animate.scale(0.7).move_to(theorem_text),\\n            run_time=2\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 2: The Right Triangle Foundation\",\n    \"code\": \"from manim import *\\n\\nclass RightTriangleFoundation(Scene):\\n    def construct(self):\\n        # Create coordinate system\\n        axes = Axes(\\n            x_range=[-1, 6, 1],\\n            y_range=[-1, 5, 1],\\n            axis_config={\\\"color\\\": BLUE_E},\\n            tips=False\\n        )\\n        axes.add_coordinates()\\n        \\n        self.play(Create(axes), run_time=2)\\n        \\n        # Define triangle vertices\\n        A = axes.c2p(0, 0)\\n        B = axes.c2p(4, 0)\\n        C = axes.c2p(4, 3)\\n        \\n        # Create triangle\\n        triangle = Polygon(A, B, C, color=WHITE, stroke_width=4)\\n        \\n        # Create right angle indicator\\n        right_angle = RightAngle(\\n            Line(B, A), Line(B, C), length=0.3, color=YELLOW\\n        )\\n        \\n        self.play(Create(triangle))\\n        self.play(Create(right_angle))\\n        \\n        # Label vertices\\n        label_A = MathTex(\\\"A\\\", color=WHITE).next_to(A, DL, buff=0.2)\\n        label_B = MathTex(\\\"B\\\", color=WHITE).next_to(B, DR, buff=0.2)\\n        label_C = MathTex(\\\"C\\\", color=WHITE).next_to(C, UR, buff=0.2)\\n        \\n        self.play(Write(label_A), Write(label_B), Write(label_C))\\n        \\n        # Label sides with animation\\n        side_a = Line(B, C, color=RED, stroke_width=6)\\n        side_b = Line(A, B, color=GREEN, stroke_width=6)\\n        side_c = Line(A, C, color=BLUE, stroke_width=6)\\n        \\n        label_a = MathTex(\\\"a\\\", color=RED, font_size=36).next_to(side_a.get_center(), RIGHT, buff=0.3)\\n        label_b = MathTex(\\\"b\\\", color=GREEN, font_size=36).next_to(side_b.get_center(), DOWN, buff=0.3)\\n        label_c = MathTex(\\\"c\\\", color=BLUE, font_size=36).next_to(side_c.get_center(), UL, buff=0.3)\\n        \\n        # Highlight each side\\n        self.play(Create(side_a), Write(label_a))\\n        self.wait(0.5)\\n        self.play(Create(side_b), Write(label_b))\\n        self.wait(0.5)\\n        self.play(Create(side_c), Write(label_c))\\n        self.wait()\\n        \\n        # Show hypotenuse is special\\n        hypotenuse_text = Text(\\\"Hypotenuse\\\", color=BLUE, font_size=28)\\n        hypotenuse_text.next_to(side_c, UP, buff=0.5)\\n        arrow = Arrow(hypotenuse_text.get_bottom(), side_c.get_center(), color=BLUE)\\n        \\n        self.play(Write(hypotenuse_text), Create(arrow))\\n        self.play(side_c.animate.set_stroke(width=8), run_time=1)\\n        self.wait(2)\\n        \\n        # Clean up for next scene\\n        self.play(\\n            FadeOut(arrow), FadeOut(hypotenuse_text),\\n            side_c.animate.set_stroke(width=6)\\n        )\\n        self.wait()\"\n  },\n  {\n    \"scene\": \"Scene 3: Visual Proof with Squares\",\n    \"code\": \"from manim import *\\n\\nclass VisualProofSquares(Scene):\\n    def construct(self):\\n        # Create the right triangle\\n        triangle = Polygon(\\n            ORIGIN, 3*RIGHT, 3*RIGHT + 4*UP,\\n            color=WHITE, stroke_width=3, fill_opacity=0.1\\n        )\\n        triangle.move_to(ORIGIN)\\n        \\n        # Create right angle marker\\n        right_angle = RightAngle(\\n            Line(3*RIGHT, ORIGIN), \\n            Line(3*RIGHT, 3*RIGHT + 4*UP),\\n            length=0.3, color=YELLOW\\n        )\\n        \\n        self.play(Create(triangle), Create(right_angle))\\n        \\n        # Create squares on each side\\n        # Square on side a (height)\\n        square_a = Square(side_length=4, color=RED, fill_opacity=0.3)\\n        square_a.move_to(3*RIGHT + 2*UP + 2*RIGHT)\\n        \\n        # Square on side b (base)\\n        square_b = Square(side_length=3, color=GREEN, fill_opacity=0.3)\\n        square_b.move_to(1.5*RIGHT - 1.5*DOWN)\\n        \\n        # Square on side c (hypotenuse)\\n        c_length = 5  # 3-4-5 triangle\\n        square_c = Square(side_length=c_length, color=BLUE, fill_opacity=0.3)\\n        square_c.rotate(np.arctan(4/3))\\n        square_c.move_to(triangle.get_vertices()[0] + 2.5*LEFT + 2.5*UP)\\n        \\n        # Animate squares appearing\\n        self.play(Create(square_a))\\n        area_a = MathTex(\\\"a^2 = 16\\\", color=RED).next_to(square_a, RIGHT)\\n        self.play(Write(area_a))\\n        \\n        self.play(Create(square_b))\\n        area_b = MathTex(\\\"b^2 = 9\\\", color=GREEN).next_to(square_b, DOWN)\\n        self.play(Write(area_b))\\n        \\n        self.play(Create(square_c))\\n        area_c = MathTex(\\\"c^2 = 25\\\", color=BLUE).next_to(square_c, LEFT)\\n        self.play(Write(area_c))\\n        \\n        # Show the relationship\\n        equation = MathTex(\\\"16 + 9 = 25\\\", font_size=48)\\n        equation.to_edge(UP)\\n        self.play(Write(equation))\\n        \\n        # Transform to general form\\n        general_equation = MathTex(\\\"a^2 + b^2 = c^2\\\", font_size=48, color=YELLOW)\\n        general_equation.move_to(equation)\\n        \\n        self.play(Transform(equation, general_equation))\\n        \\n        # Highlight the squares pulsing\\n        self.play(\\n            square_a.animate.set_fill(RED, 0.6),\\n            square_b.animate.set_fill(GREEN, 0.6),\\n            run_time=1\\n        )\\n        self.play(\\n            square_c.animate.set_fill(BLUE, 0.6),\\n            run_time=1\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 4: Algebraic Proof\",\n    \"code\": \"from manim import *\\n\\nclass AlgebraicProof(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Algebraic Proof of the Pythagorean Theorem\\\", font_size=36, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # Create a square with side length (a+b)\\n        big_square = Square(side_length=4, color=WHITE)\\n        big_square.shift(LEFT*2)\\n        \\n        # Create internal divisions\\n        a_len = 2.4  # represents 'a'\\n        b_len = 1.6  # represents 'b'\\n        \\n        # Four triangles\\n        triangles = VGroup()\\n        colors = [RED, GREEN, BLUE, ORANGE]\\n        positions = [\\n            (big_square.get_corner(DL), RIGHT*b_len, UP*a_len),\\n            (big_square.get_corner(DL) + RIGHT*b_len, UP*a_len, RIGHT*a_len),\\n            (big_square.get_corner(UR), LEFT*b_len, DOWN*a_len),\\n            (big_square.get_corner(UR) - RIGHT*a_len, DOWN*a_len, LEFT*b_len)\\n        ]\\n        \\n        for i, (start, v1, v2) in enumerate(positions):\\n            triangle = Polygon(start, start + v1, start + v1 + v2, \\n                             color=colors[i], fill_opacity=0.5, stroke_width=2)\\n            triangles.add(triangle)\\n        \\n        # Inner square\\n        c_len = np.sqrt(a_len**2 + b_len**2)\\n        inner_square = Square(side_length=c_len, color=YELLOW, fill_opacity=0.3)\\n        inner_square.rotate(np.arctan(a_len/b_len))\\n        inner_square.move_to(big_square.get_center())\\n        \\n        self.play(Create(big_square))\\n        self.play(*[Create(t) for t in triangles])\\n        self.play(Create(inner_square))\\n        \\n        # Labels\\n        label_a = MathTex(\\\"a\\\", color=WHITE).scale(0.8)\\n        label_b = MathTex(\\\"b\\\", color=WHITE).scale(0.8)\\n        label_c = MathTex(\\\"c\\\", color=YELLOW).scale(0.8)\\n        \\n        label_a.next_to(big_square.get_left() + UP*a_len/2, LEFT)\\n        label_b.next_to(big_square.get_bottom() + RIGHT*b_len/2, DOWN)\\n        label_c.move_to(inner_square.get_center())\\n        \\n        self.play(Write(label_a), Write(label_b), Write(label_c))\\n        \\n        # Mathematical explanation\\n        explanation = VGroup(\\n            MathTex(r\\\"\\\\text{Area of big square} = (a+b)^2\\\", font_size=32),\\n            MathTex(r\\\"\\\\text{Also} = 4 \\\\times \\\\frac{1}{2}ab + c^2\\\", font_size=32),\\n            MathTex(r\\\"(a+b)^2 = 2ab + c^2\\\", font_size=32),\\n            MathTex(r\\\"a^2 + 2ab + b^2 = 2ab + c^2\\\", font_size=32),\\n            MathTex(r\\\"a^2 + b^2 = c^2\\\", font_size=36, color=YELLOW)\\n        ).arrange(DOWN, aligned_edge=LEFT)\\n        explanation.shift(RIGHT*3)\\n        \\n        for i, eq in enumerate(explanation):\\n            self.play(Write(eq))\\n            self.wait(1)\\n            if i == len(explanation) - 1:\\n                self.play(eq.animate.scale(1.2).set_color(YELLOW))\\n        \\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 5: Real World Applications - Architecture\",\n    \"code\": \"from manim import *\\n\\nclass RealWorldArchitecture(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Pythagorean Theorem in Architecture\\\", font_size=40, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # Create a building frame\\n        base = Line(LEFT*3, RIGHT*3, color=GREY, stroke_width=8)\\n        height = Line(LEFT*3, LEFT*3 + UP*4, color=GREY, stroke_width=8)\\n        \\n        self.play(Create(base), Create(height))\\n        \\n        # Add diagonal support beam\\n        diagonal = Line(LEFT*3 + UP*4, RIGHT*3, color=YELLOW, stroke_width=6)\\n        \\n        # Show the problem\\n        question = Text(\\\"How long should the support beam be?\\\", font_size=24)\\n        question.next_to(base, DOWN, buff=1)\\n        self.play(Write(question))\\n        \\n        # Label dimensions\\n        base_label = MathTex(\\\"6\\\\text{ m}\\\", color=WHITE).next_to(base, DOWN)\\n        height_label = MathTex(\\\"4\\\\text{ m}\\\", color=WHITE).next_to(height, LEFT)\\n        \\n        self.play(Write(base_label), Write(height_label))\\n        \\n        # Apply Pythagorean theorem\\n        calculation = VGroup(\\n            MathTex(r\\\"c^2 = a^2 + b^2\\\"),\\n            MathTex(r\\\"c^2 = 4^2 + 6^2\\\"),\\n            MathTex(r\\\"c^2 = 16 + 36\\\"),\\n            MathTex(r\\\"c^2 = 52\\\"),\\n            MathTex(r\\\"c = \\\\sqrt{52} \\\\approx 7.21\\\\text{ m}\\\", color=YELLOW)\\n        ).arrange(DOWN, aligned_edge=LEFT).scale(0.8)\\n        calculation.next_to(question, DOWN)\\n        \\n        self.play(Create(diagonal))\\n        diagonal_label = MathTex(\\\"c = 7.21\\\\text{ m}\\\", color=YELLOW).next_to(diagonal.get_center(), UR)\\n        \\n        for step in calculation:\\n            self.play(Write(step))\\n            self.wait(0.5)\\n        \\n        self.play(Write(diagonal_label))\\n        \\n        # Show stability improvement\\n        stability_text = Text(\\\"Diagonal bracing provides stability\\\", font_size=28, color=GREEN)\\n        stability_text.to_edge(DOWN)\\n        self.play(Write(stability_text))\\n        \\n        # Animate the structure wobbling without support\\n        self.play(\\n            diagonal.animate.set_opacity(0.2),\\n            height.animate.rotate(0.1, about_point=LEFT*3),\\n            rate_func=there_and_back,\\n            run_time=1\\n        )\\n        \\n        self.play(\\n            diagonal.animate.set_opacity(1),\\n            height.animate.rotate(0, about_point=LEFT*3)\\n        )\\n        \\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 6: Distance Formula Connection\",\n    \"code\": \"from manim import *\\n\\nclass DistanceFormulaConnection(Scene):\\n    def construct(self):\\n        # Create coordinate plane\\n        plane = NumberPlane(\\n            x_range=[-5, 5, 1],\\n            y_range=[-5, 5, 1],\\n            background_line_style={\\\"stroke_opacity\\\": 0.4}\\n        )\\n        plane.add_coordinates()\\n        self.play(Create(plane))\\n        \\n        # Title\\n        title = Text(\\\"From Pythagorean Theorem to Distance Formula\\\", font_size=32, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # Two points\\n        p1 = Dot(plane.c2p(1, 2), color=RED, radius=0.1)\\n        p2 = Dot(plane.c2p(4, 6), color=BLUE, radius=0.1)\\n        \\n        label1 = MathTex(\\\"(x_1, y_1)\\\", color=RED, font_size=24).next_to(p1, DL)\\n        label2 = MathTex(\\\"(x_2, y_2)\\\", color=BLUE, font_size=24).next_to(p2, UR)\\n        \\n        self.play(Create(p1), Create(p2), Write(label1), Write(label2))\\n        \\n        # Draw the right triangle\\n        horizontal = Line(p1.get_center(), plane.c2p(4, 2), color=GREEN, stroke_width=3)\\n        vertical = Line(plane.c2p(4, 2), p2.get_center(), color=ORANGE, stroke_width=3)\\n        hypotenuse = Line(p1.get_center(), p2.get_center(), color=YELLOW, stroke_width=4)\\n        \\n        # Right angle marker\\n        right_angle = RightAngle(\\n            horizontal, vertical, length=0.3, color=WHITE\\n        )\\n        \\n        self.play(Create(horizontal), Create(vertical))\\n        self.play(Create(right_angle))\\n        self.play(Create(hypotenuse))\\n        \\n        # Label the sides\\n        h_label = MathTex(\\\"x_2 - x_1\\\", color=GREEN, font_size=20).next_to(horizontal, DOWN)\\n        v_label = MathTex(\\\"y_2 - y_1\\\", color=ORANGE, font_size=20).next_to(vertical, RIGHT)\\n        d_label = MathTex(\\\"d\\\", color=YELLOW, font_size=24).next_to(hypotenuse.get_center(), UL)\\n        \\n        self.play(Write(h_label), Write(v_label), Write(d_label))\\n        \\n        # Derive the distance formula\\n        derivation = VGroup(\\n            MathTex(r\\\"d^2 = (x_2 - x_1)^2 + (y_2 - y_1)^2\\\"),\\n            MathTex(r\\\"d = \\\\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\\", color=YELLOW)\\n        ).arrange(DOWN).scale(0.9)\\n        derivation.to_edge(DOWN)\\n        \\n        self.play(Write(derivation[0]))\\n        self.wait(1)\\n        self.play(Write(derivation[1]))\\n        \\n        # Show specific calculation\\n        specific = VGroup(\\n            MathTex(r\\\"d = \\\\sqrt{(4-1)^2 + (6-2)^2}\\\"),\\n            MathTex(r\\\"d = \\\\sqrt{3^2 + 4^2}\\\"),\\n            MathTex(r\\\"d = \\\\sqrt{9 + 16}\\\"),\\n            MathTex(r\\\"d = \\\\sqrt{25} = 5\\\", color=YELLOW)\\n        ).arrange(DOWN).scale(0.7)\\n        specific.next_to(derivation, RIGHT, buff=1)\\n        \\n        for step in specific:\\n            self.play(Write(step))\\n            self.wait(0.5)\\n        \\n        # Highlight the distance\\n        self.play(\\n            hypotenuse.animate.set_stroke(width=6),\\n            d_label.animate.scale(1.5).set_color(YELLOW)\\n        )\\n        \\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 7: 3D Extension - Space Diagonal\",\n    \"code\": \"from manim import *\\n\\nclass SpaceDiagonal3D(ThreeDScene):\\n    def construct(self):\\n        # Set up 3D axes\\n        axes = ThreeDAxes(\\n            x_range=[-1, 5, 1],\\n            y_range=[-1, 5, 1],\\n            z_range=[-1, 5, 1],\\n            axis_config={\\\"color\\\": BLUE_E}\\n        )\\n        \\n        # Title\\n        title = Text(\\\"Pythagorean Theorem in 3D\\\", font_size=36, color=GOLD)\\n        title.to_edge(UP)\\n        self.add_fixed_in_frame_mobjects(title)\\n        self.play(Write(title))\\n        \\n        self.set_camera_orientation(phi=60*DEGREES, theta=-45*DEGREES)\\n        self.play(Create(axes))\\n        \\n        # Create a rectangular box\\n        a, b, c = 3, 4, 5\\n        vertices = [\\n            [0, 0, 0], [a, 0, 0], [a, b, 0], [0, b, 0],\\n            [0, 0, c], [a, 0, c], [a, b, c], [0, b, c]\\n        ]\\n        \\n        # Create edges\\n        edges = []\\n        edge_pairs = [\\n            (0, 1), (1, 2), (2, 3), (3, 0),  # bottom face\\n            (4, 5), (5, 6), (6, 7), (7, 4),  # top face\\n            (0, 4), (1, 5), (2, 6), (3, 7)   # vertical edges\\n        ]\\n        \\n        for i, j in edge_pairs:\\n            edge = Line3D(\\n                start=vertices[i],\\n                end=vertices[j],\\n                color=WHITE,\\n                stroke_width=2\\n            )\\n            edges.append(edge)\\n        \\n        box = VGroup(*edges)\\n        self.play(*[Create(edge) for edge in edges])\\n        \\n        # Highlight the three dimensions\\n        dim_a = Line3D([0, 0, 0], [a, 0, 0], color=RED, stroke_width=4)\\n        dim_b = Line3D([a, 0, 0], [a, b, 0], color=GREEN, stroke_width=4)\\n        dim_c = Line3D([0, 0, 0], [0, 0, c], color=BLUE, stroke_width=4)\\n        \\n        label_a = Text(\\\"a=3\\\", color=RED, font_size=24)\\n        label_b = Text(\\\"b=4\\\", color=GREEN, font_size=24)\\n        label_c = Text(\\\"c=5\\\", color=BLUE, font_size=24)\\n        \\n        self.add_fixed_in_frame_mobjects(label_a, label_b, label_c)\\n        label_a.next_to(title, DOWN).shift(LEFT*3)\\n        label_b.next_to(label_a, RIGHT)\\n        label_c.next_to(label_b, RIGHT)\\n        \\n        self.play(Create(dim_a), Write(label_a))\\n        self.play(Create(dim_b), Write(label_b))\\n        self.play(Create(dim_c), Write(label_c))\\n        \\n        # Create space diagonal\\n        space_diagonal = Line3D([0, 0, 0], [a, b, c], color=YELLOW, stroke_width=6)\\n        \\n        # Show intermediate diagonals\\n        base_diagonal = Line3D([0, 0, 0], [a, b, 0], color=ORANGE, stroke_width=4)\\n        \\n        self.play(Create(base_diagonal))\\n        \\n        # Show calculation\\n        calc1 = MathTex(r\\\"d_{base} = \\\\sqrt{a^2 + b^2} = \\\\sqrt{9 + 16} = 5\\\", font_size=28)\\n        self.add_fixed_in_frame_mobjects(calc1)\\n        calc1.to_edge(DOWN).shift(UP*0.5)\\n        self.play(Write(calc1))\\n        \\n        self.play(Create(space_diagonal))\\n        \\n        calc2 = MathTex(r\\\"d_{space} = \\\\sqrt{d_{base}^2 + c^2} = \\\\sqrt{25 + 25} = 5\\\\sqrt{2}\\\", \\n                       font_size=28, color=YELLOW)\\n        self.add_fixed_in_frame_mobjects(calc2)\\n        calc2.next_to(calc1, DOWN)\\n        self.play(Write(calc2))\\n        \\n        # Rotate to show 3D perspective\\n        self.begin_ambient_camera_rotation(rate=0.2)\\n        self.wait(5)\\n        self.stop_ambient_camera_rotation()\\n        \\n        # Final formula\\n        final = MathTex(r\\\"d = \\\\sqrt{a^2 + b^2 + c^2}\\\", font_size=32, color=GOLD)\\n        self.add_fixed_in_frame_mobjects(final)\\n        final.to_edge(DOWN)\\n        self.play(Transform(calc2, final))\\n        \\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 8: Circle and Unit Circle Connection\",\n    \"code\": \"from manim import *\\n\\nclass CircleConnection(Scene):\\n    def construct(self):\\n        # Create coordinate system\\n        plane = NumberPlane(\\n            x_range=[-4, 4, 1],\\n            y_range=[-4, 4, 1],\\n            background_line_style={\\\"stroke_opacity\\\": 0.4}\\n        )\\n        plane.add_coordinates()\\n        self.play(Create(plane))\\n        \\n        # Title\\n        title = Text(\\\"Pythagorean Theorem and the Circle\\\", font_size=36, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # Create unit circle\\n        circle = Circle(radius=2, color=BLUE, stroke_width=3)\\n        self.play(Create(circle))\\n        \\n        # Add radius label\\n        radius_label = MathTex(\\\"r = 2\\\", color=BLUE).shift(1.5*UP + 1.5*RIGHT)\\n        self.play(Write(radius_label))\\n        \\n        # Pick a point on the circle\\n        angle = PI/3\\n        point = Dot(2*np.cos(angle)*RIGHT + 2*np.sin(angle)*UP, color=RED, radius=0.08)\\n        \\n        # Draw lines from origin to point\\n        x_line = Line(ORIGIN, 2*np.cos(angle)*RIGHT, color=GREEN, stroke_width=3)\\n        y_line = Line(2*np.cos(angle)*RIGHT, point.get_center(), color=ORANGE, stroke_width=3)\\n        radius_line = Line(ORIGIN, point.get_center(), color=RED, stroke_width=3)\\n        \\n        # Right angle marker\\n        right_angle = RightAngle(x_line, y_line, length=0.2, color=YELLOW)\\n        \\n        self.play(Create(radius_line), Create(point))\\n        self.play(Create(x_line), Create(y_line), Create(right_angle))\\n        \\n        # Labels\\n        x_label = MathTex(\\\"x\\\", color=GREEN).next_to(x_line, DOWN)\\n        y_label = MathTex(\\\"y\\\", color=ORANGE).next_to(y_line, RIGHT)\\n        r_label = MathTex(\\\"r\\\", color=RED).next_to(radius_line.get_center(), UL)\\n        \\n        self.play(Write(x_label), Write(y_label), Write(r_label))\\n        \\n        # Show the equation\\n        equation = MathTex(r\\\"x^2 + y^2 = r^2\\\", font_size=48)\\n        equation.shift(3*DOWN)\\n        self.play(Write(equation))\\n        \\n        # For unit circle\\n        unit_circle_eq = MathTex(r\\\"\\\\text{For unit circle: } x^2 + y^2 = 1\\\", \\n                                font_size=36, color=YELLOW)\\n        unit_circle_eq.next_to(equation, DOWN)\\n        self.play(Write(unit_circle_eq))\\n        \\n        # Animate point moving around circle\\n        def update_point(mob, dt):\\n            mob.angle += dt\\n            mob.move_to(2*np.cos(mob.angle)*RIGHT + 2*np.sin(mob.angle)*UP)\\n        \\n        point.angle = angle\\n        \\n        # Update lines as point moves\\n        x_line.add_updater(lambda m: m.become(\\n            Line(ORIGIN, point.get_center()[0]*RIGHT, color=GREEN, stroke_width=3)\\n        ))\\n        y_line.add_updater(lambda m: m.become(\\n            Line(point.get_center()[0]*RIGHT, point.get_center(), color=ORANGE, stroke_width=3)\\n        ))\\n        radius_line.add_updater(lambda m: m.become(\\n            Line(ORIGIN, point.get_center(), color=RED, stroke_width=3)\\n        ))\\n        \\n        # Show coordinates changing\\n        coords = DecimalNumber(0).shift(3*LEFT + 2*DOWN)\\n        coords_text = always_redraw(lambda: MathTex(\\n            f\\\"({point.get_center()[0]:.2f}, {point.get_center()[1]:.2f})\\\",\\n            font_size=28\\n        ).shift(3*LEFT + 2*DOWN))\\n        \\n        self.add(coords_text)\\n        point.add_updater(update_point)\\n        \\n        self.wait(4)\\n        \\n        # Clean up\\n        point.clear_updaters()\\n        x_line.clear_updaters()\\n        y_line.clear_updaters()\\n        radius_line.clear_updaters()\\n        \\n        self.wait()\"\n  },\n  {\n    \"scene\": \"Scene 9: Special Right Triangles\",\n    \"code\": \"from manim import *\\n\\nclass SpecialRightTriangles(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Special Right Triangles\\\", font_size=40, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # 45-45-90 triangle\\n        triangle_45 = Polygon(\\n            ORIGIN, 2*RIGHT, 2*RIGHT + 2*UP,\\n            color=BLUE, stroke_width=3, fill_opacity=0.2\\n        )\\n        triangle_45.shift(LEFT*4 + DOWN)\\n        \\n        # Right angle marker\\n        right_angle_45 = RightAngle(\\n            Line(2*RIGHT, ORIGIN), Line(2*RIGHT, 2*RIGHT + 2*UP),\\n            length=0.3, color=YELLOW\\n        ).shift(LEFT*4 + DOWN)\\n        \\n        # 30-60-90 triangle\\n        triangle_30 = Polygon(\\n            ORIGIN, 2*np.sqrt(3)*RIGHT, 2*np.sqrt(3)*RIGHT + 2*UP,\\n            color=RED, stroke_width=3, fill_opacity=0.2\\n        )\\n        triangle_30.shift(RIGHT*2 + DOWN)\\n        \\n        right_angle_30 = RightAngle(\\n            Line(2*np.sqrt(3)*RIGHT, ORIGIN), \\n            Line(2*np.sqrt(3)*RIGHT, 2*np.sqrt(3)*RIGHT + 2*UP),\\n            length=0.3, color=YELLOW\\n        ).shift(RIGHT*2 + DOWN)\\n        \\n        self.play(Create(triangle_45), Create(right_angle_45))\\n        self.play(Create(triangle_30), Create(right_angle_30))\\n        \\n        # Labels for 45-45-90\\n        label_45_1 = MathTex(\\\"45°\\\", font_size=24, color=BLUE)\\n        label_45_1.next_to(triangle_45.get_vertices()[0], DR, buff=0.3)\\n        label_45_2 = MathTex(\\\"45°\\\", font_size=24, color=BLUE)\\n        label_45_2.next_to(triangle_45.get_vertices()[2], UL, buff=0.3)\\n        \\n        side_45_1 = MathTex(\\\"1\\\", font_size=28, color=WHITE).next_to(triangle_45.get_bottom(), DOWN)\\n        side_45_2 = MathTex(\\\"1\\\", font_size=28, color=WHITE).next_to(triangle_45.get_right(), RIGHT)\\n        hyp_45 = MathTex(\\\"\\\\sqrt{2}\\\", font_size=28, color=YELLOW)\\n        hyp_45.move_to(triangle_45.get_center() + 0.7*UL)\\n        \\n        self.play(Write(label_45_1), Write(label_45_2))\\n        self.play(Write(side_45_1), Write(side_45_2), Write(hyp_45))\\n        \\n        # Labels for 30-60-90\\n        label_30 = MathTex(\\\"30°\\\", font_size=24, color=RED)\\n        label_30.next_to(triangle_30.get_vertices()[0], DR, buff=0.3)\\n        label_60 = MathTex(\\\"60°\\\", font_size=24, color=RED)\\n        label_60.next_to(triangle_30.get_vertices()[2], UL, buff=0.3)\\n        \\n        side_30_1 = MathTex(\\\"\\\\sqrt{3}\\\", font_size=28, color=WHITE)\\n        side_30_1.next_to(triangle_30.get_bottom(), DOWN)\\n        side_30_2 = MathTex(\\\"1\\\", font_size=28, color=WHITE)\\n        side_30_2.next_to(triangle_30.get_right(), RIGHT)\\n        hyp_30 = MathTex(\\\"2\\\", font_size=28, color=YELLOW)\\n        hyp_30.move_to(triangle_30.get_center() + 0.7*UL)\\n        \\n        self.play(Write(label_30), Write(label_60))\\n        self.play(Write(side_30_1), Write(side_30_2), Write(hyp_30))\\n        \\n        # Show the ratios\\n        ratio_45 = MathTex(r\\\"1 : 1 : \\\\sqrt{2}\\\", font_size=32, color=BLUE)\\n        ratio_45.next_to(triangle_45, UP, buff=0.5)\\n        \\n        ratio_30 = MathTex(r\\\"1 : \\\\sqrt{3} : 2\\\", font_size=32, color=RED)\\n        ratio_30.next_to(triangle_30, UP, buff=0.5)\\n        \\n        self.play(Write(ratio_45), Write(ratio_30))\\n        \\n        # Verification with Pythagorean theorem\\n        verify_45 = MathTex(r\\\"1^2 + 1^2 = (\\\\sqrt{2})^2 \\\\checkmark\\\", font_size=28)\\n        verify_45.shift(2*DOWN + 3*LEFT)\\n        \\n        verify_30 = MathTex(r\\\"1^2 + (\\\\sqrt{3})^2 = 2^2 \\\\checkmark\\\", font_size=28)\\n        verify_30.shift(2*DOWN + 3*RIGHT)\\n        \\n        self.play(Write(verify_45))\\n        self.play(Write(verify_30))\\n        \\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 10: Interactive Problem Solving\",\n    \"code\": \"from manim import *\\n\\nclass InteractiveProblemSolving(Scene):\\n    def construct(self):\\n        # Problem setup\\n        title = Text(\\\"Problem: Ladder Against a Wall\\\", font_size=36, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # Create the scenario\\n        ground = Line(LEFT*4, RIGHT*4, color=BROWN, stroke_width=6)\\n        ground.shift(DOWN*3)\\n        wall = Line(LEFT*3 + DOWN*3, LEFT*3 + UP*3, color=GREY, stroke_width=6)\\n        \\n        self.play(Create(ground), Create(wall))\\n        \\n        # Add ladder\\n        ladder_bottom = RIGHT*2 + DOWN*3\\n        ladder_top = LEFT*3 + UP*1\\n        ladder = Line(ladder_bottom, ladder_top, color=YELLOW, stroke_width=8)\\n        \\n        self.play(Create(ladder))\\n        \\n        # Problem text\\n        problem = VGroup(\\n            Text(\\\"A 10-foot ladder leans against a wall.\\\", font_size=24),\\n            Text(\\\"The bottom is 6 feet from the wall.\\\", font_size=24),\\n            Text(\\\"How high does it reach?\\\", font_size=24, color=YELLOW)\\n        ).arrange(DOWN, aligned_edge=LEFT)\\n        problem.shift(RIGHT*2 + UP*2)\\n        \\n        self.play(Write(problem))\\n        \\n        # Show measurements\\n        ladder_length = MathTex(\\\"10\\\\text{ ft}\\\", color=YELLOW).next_to(ladder.get_center(), UR)\\n        ground_dist = MathTex(\\\"6\\\\text{ ft}\\\", color=GREEN).next_to(ground, DOWN).shift(RIGHT*0.5)\\n        \\n        # Distance indicators\\n        ground_measure = DoubleArrow(\\n            LEFT*3 + DOWN*3.5, RIGHT*2 + DOWN*3.5,\\n            color=GREEN, stroke_width=3\\n        )\\n        \\n        self.play(Create(ground_measure), Write(ground_dist))\\n        self.play(Write(ladder_length))\\n        \\n        # Height to find\\n        height_measure = DoubleArrow(\\n            LEFT*3.5 + DOWN*3, LEFT*3.5 + UP*1,\\n            color=RED, stroke_width=3\\n        )\\n        height_label = MathTex(\\\"h = ?\\\", color=RED).next_to(height_measure, LEFT)\\n        \\n        self.play(Create(height_measure), Write(height_label))\\n        \\n        # Show right triangle\\n        triangle = Polygon(\\n            ladder_bottom, ladder_top, LEFT*3 + DOWN*3,\\n            color=WHITE, stroke_width=2, fill_opacity=0.1\\n        )\\n        right_angle = RightAngle(\\n            Line(LEFT*3 + DOWN*3, ladder_bottom),\\n            Line(LEFT*3 + DOWN*3, ladder_top),\\n            length=0.3, color=YELLOW\\n        )\\n        \\n        self.play(Create(triangle), Create(right_angle))\\n        \\n        # Solution steps\\n        solution = VGroup(\\n            MathTex(r\\\"a^2 + b^2 = c^2\\\"),\\n            MathTex(r\\\"h^2 + 6^2 = 10^2\\\"),\\n            MathTex(r\\\"h^2 + 36 = 100\\\"),\\n            MathTex(r\\\"h^2 = 64\\\"),\\n            MathTex(r\\\"h = 8\\\\text{ ft}\\\", color=RED)\\n        ).arrange(DOWN, aligned_edge=LEFT).scale(0.8)\\n        solution.shift(RIGHT*2 + DOWN*0.5)\\n        \\n        # Clear problem text for solution\\n        self.play(FadeOut(problem))\\n        \\n        for step in solution:\\n            self.play(Write(step))\\n            self.wait(0.7)\\n        \\n        # Update height label\\n        new_height_label = MathTex(\\\"h = 8\\\\text{ ft}\\\", color=RED).next_to(height_measure, LEFT)\\n        self.play(Transform(height_label, new_height_label))\\n        \\n        # Verify with animation\\n        check = Text(\\\"✓ Verified!\\\", color=GREEN, font_size=32)\\n        check.next_to(solution, DOWN)\\n        self.play(Write(check))\\n        \\n        # Show practical application\\n        safety_note = Text(\\n            \\\"Safety tip: Use the 4:1 rule - \\\\nbase should be 1/4 of working height\\\",\\n            font_size=20, color=ORANGE\\n        )\\n        safety_note.to_edge(DOWN)\\n        self.play(Write(safety_note))\\n        \\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 11: Historical Proofs Comparison\",\n    \"code\": \"from manim import *\\n\\nclass HistoricalProofsComparison(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Multiple Proofs Throughout History\\\", font_size=36, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # Timeline\\n        timeline = Line(LEFT*6, RIGHT*6, color=WHITE)\\n        timeline.shift(UP*2)\\n        self.play(Create(timeline))\\n        \\n        # Historical points\\n        dates = [\\\"~1900 BCE\\\", \\\"~570 BCE\\\", \\\"~300 BCE\\\", \\\"~250 CE\\\", \\\"1876 CE\\\"]\\n        names = [\\\"Babylonians\\\", \\\"Pythagoras\\\", \\\"Euclid\\\", \\\"Liu Hui\\\", \\\"Garfield\\\"]\\n        positions = [LEFT*5, LEFT*2.5, ORIGIN, RIGHT*2.5, RIGHT*5]\\n        \\n        for date, name, pos in zip(dates, names, positions):\\n            dot = Dot(pos + UP*2, color=YELLOW)\\n            date_text = Text(date, font_size=16).next_to(dot, UP)\\n            name_text = Text(name, font_size=20).next_to(dot, DOWN)\\n            \\n            self.play(Create(dot), Write(date_text), Write(name_text))\\n        \\n        # Show different proof methods\\n        self.play(FadeOut(timeline), *[FadeOut(mob) for mob in self.mobjects if mob != title])\\n        \\n        # Euclidean proof visualization\\n        euclidean_title = Text(\\\"Euclid's Proof\\\", font_size=28, color=BLUE)\\n        euclidean_title.shift(LEFT*4 + UP*0.5)\\n        self.play(Write(euclidean_title))\\n        \\n        # Create Euclidean diagram\\n        triangle = Polygon(\\n            ORIGIN, RIGHT*1.5, RIGHT*1.5 + UP*2,\\n            color=WHITE, stroke_width=2\\n        ).shift(LEFT*4 + DOWN*2)\\n        \\n        squares = VGroup()\\n        # Square on each side\\n        sq1 = Square(side_length=1.5, color=RED, fill_opacity=0.3).shift(LEFT*4 + DOWN*2.75)\\n        sq2 = Square(side_length=2, color=GREEN, fill_opacity=0.3).shift(LEFT*2.5 + DOWN*1 + RIGHT*1)\\n        sq3 = Square(side_length=2.5, color=BLUE, fill_opacity=0.3)\\n        sq3.rotate(np.arctan(2/1.5)).shift(LEFT*4.7 + DOWN*0.5)\\n        \\n        squares.add(sq1, sq2, sq3)\\n        \\n        self.play(Create(triangle))\\n        self.play(*[Create(sq) for sq in squares])\\n        \\n        # Chinese proof visualization\\n        chinese_title = Text(\\\"Chinese Proof\\\", font_size=28, color=RED)\\n        chinese_title.shift(RIGHT*4 + UP*0.5)\\n        self.play(Write(chinese_title))\\n        \\n        # Create Chinese diagram (dissection proof)\\n        big_square = Square(side_length=3, color=WHITE).shift(RIGHT*4 + DOWN*1.5)\\n        inner_square = Square(side_length=1.8, color=YELLOW, fill_opacity=0.3)\\n        inner_square.rotate(PI/4).shift(RIGHT*4 + DOWN*1.5)\\n        \\n        # Four triangles\\n        triangles = VGroup()\\n        for i in range(4):\\n            tri = Polygon(\\n                ORIGIN, RIGHT*0.9, UP*1.2,\\n                color=BLUE, fill_opacity=0.5, stroke_width=1\\n            )\\n            tri.rotate(i * PI/2, about_point=ORIGIN)\\n            tri.shift(RIGHT*4 + DOWN*1.5)\\n            triangles.add(tri)\\n        \\n        self.play(Create(big_square))\\n        self.play(*[Create(tri) for tri in triangles])\\n        self.play(Create(inner_square))\\n        \\n        # Summary text\\n        summary = Text(\\n            \\\"Over 400 different proofs exist!\\\",\\n            font_size=32, color=YELLOW\\n        )\\n        summary.to_edge(DOWN)\\n        self.play(Write(summary))\\n        \\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 12: Modern Applications and Future\",\n    \"code\": \"from manim import *\\n\\nclass ModernApplicationsFuture(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Pythagorean Theorem in the Modern World\\\", font_size=36, color=GOLD)\\n        title.to_edge(UP)\\n        self.play(Write(title))\\n        \\n        # GPS Navigation\\n        gps_title = Text(\\\"GPS Navigation\\\", font_size=28, color=BLUE)\\n        gps_title.shift(LEFT*4 + UP*2)\\n        self.play(Write(gps_title))\\n        \\n        # Create simplified GPS scenario\\n        earth = Circle(radius=1, color=BLUE, fill_opacity=0.3).shift(LEFT*4)\\n        satellite = Dot(LEFT*4 + UP*2, color=RED)\\n        receiver = Dot(LEFT*4 + RIGHT*0.7 + DOWN*0.5, color=GREEN)\\n        \\n        self.play(Create(earth), Create(satellite), Create(receiver))\\n        \\n        # Distance calculation\\n        distance_line = DashedLine(satellite.get_center(), receiver.get_center(), color=YELLOW)\\n        self.play(Create(distance_line))\\n        \\n        gps_formula = MathTex(r\\\"d = \\\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2}\\\", font_size=20)\\n        gps_formula.next_to(earth, DOWN)\\n        self.play(Write(gps_formula))\\n        \\n        # Computer Graphics\\n        cg_title = Text(\\\"Computer Graphics\\\", font_size=28, color=GREEN)\\n        cg_title.shift(RIGHT*4 + UP*2)\\n        self.play(Write(cg_title))\\n        \\n        # 3D rotation visualization\\n        cube_vertices = [\\n            np.array([1, 1, 1]), np.array([-1, 1, 1]), \\n            np.array([-1, -1, 1]), np.array([1, -1, 1]),\\n            np.array([1, 1, -1]), np.array([-1, 1, -1]),\\n            np.array([-1, -1, -1]), np.array([1, -1, -1])\\n        ]\\n        \\n        # Project to 2D\\n        projected_vertices = []\\n        for v in cube_vertices:\\n            # Simple perspective projection\\n            scale = 1 / (3 - v[2])\\n            x = v[0] * scale\\n            y = v[1] * scale\\n            projected_vertices.append(np.array([x, y, 0]) * 0.5 + RIGHT*4)\\n        \\n        # Draw cube edges\\n        edges = [\\n            (0, 1), (1, 2), (2, 3), (3, 0),\\n            (4, 5), (5, 6), (6, 7), (7, 4),\\n            (0, 4), (1, 5), (2, 6), (3, 7)\\n        ]\\n        \\n        cube_edges = VGroup()\\n        for i, j in edges:\\n            edge = Line(projected_vertices[i], projected_vertices[j], color=GREEN, stroke_width=2)\\n            cube_edges.add(edge)\\n        \\n        self.play(*[Create(edge) for edge in cube_edges])\\n        \\n        # Machine Learning\\n        ml_title = Text(\\\"Machine Learning\\\", font_size=28, color=PURPLE)\\n        ml_title.shift(DOWN*1.5)\\n        self.play(Write(ml_title))\\n        \\n        # Distance in feature space\\n        feature_space = NumberPlane(\\n            x_range=[-3, 3, 1],\\n            y_range=[-2, 2, 1],\\n            background_line_style={\\\"stroke_opacity\\\": 0.2}\\n        ).scale(0.5).shift(DOWN*3)\\n        \\n        self.play(Create(feature_space))\\n        \\n        # Data points\\n        points = VGroup()\\n        for _ in range(10):\\n            point = Dot(\\n                feature_space.c2p(np.random.uniform(-2, 2), np.random.uniform(-1, 1)),\\n                color=np.random.choice([RED, BLUE]),\\n                radius=0.05\\n            )\\n            points.add(point)\\n        \\n        self.play(*[Create(p) for p in points])\\n        \\n        # Show distance calculation\\n        p1, p2 = points[0], points[1]\\n        dist_line = Line(p1.get_center(), p2.get_center(), color=YELLOW, stroke_width=2)\\n        self.play(Create(dist_line))\\n        \\n        ml_formula = MathTex(r\\\"\\\\text{Euclidean Distance in n-dimensions}\\\", font_size=20)\\n        ml_formula.next_to(feature_space, RIGHT)\\n        self.play(Write(ml_formula))\\n        \\n        # Final message\\n        final_message = VGroup(\\n            Text(\\\"From ancient geometry to modern AI,\\\", font_size=24),\\n            Text(\\\"the Pythagorean theorem remains fundamental\\\", font_size=24),\\n            Text(\\\"to our understanding of space and distance.\\\", font_size=24, color=YELLOW)\\n        ).arrange(DOWN)\\n        \\n        self.play(\\n            *[FadeOut(mob) for mob in self.mobjects if mob != title],\\n            title.animate.move_to(UP*2)\\n        )\\n        \\n        final_message.next_to(title, DOWN, buff=1)\\n        self.play(Write(final_message))\\n        \\n        # Closing equation\\n        closing = MathTex(r\\\"a^2 + b^2 = c^2\\\", font_size=72, color=GOLD)\\n        closing.next_to(final_message, DOWN, buff=1)\\n        self.play(Write(closing))\\n        self.play(closing.animate.scale(1.2), run_time=1)\\n        \\n        self.wait(3)\"\n  }\n]"
}

// Function to robustly parse the LLM output string
function robustParseLLMOutput(rawObj: { output: string }): any[] | null {
  let outputStr = rawObj.output.trim();

  // Step 1: Strip ```json ... ``` or ``` ... ```
  const codeBlockRegex = /^```(?:json)?\s*([\s\S]*?)\s*```$/;
  const match = outputStr.match(codeBlockRegex);
  if (match) {
    outputStr = match[1].trim();
  }

  // Step 2: Try parsing
  try {
    const parsed = JSON.parse(outputStr);
    return parsed;
  } catch (err) {
    console.error('Failed to parse output:', err);
    return null;
  }
}


async function main() {
  const parsedOutput = robustParseLLMOutput(raw);
  if (parsedOutput) {
    const outputPath = path.join(process.cwd(), 'app', 'api', 'output', 'output.json');
    await fs.writeFile(outputPath, JSON.stringify(parsedOutput, null, 2), 'utf-8');
    console.log('Output written to output/output.json');
  } else {
    console.error('Failed to parse LLM output.');
  }
}

main(); 