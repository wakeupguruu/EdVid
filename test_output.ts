import { promises as fs } from 'fs';
import path from 'path';

// Your raw LLM output as a JS object
const raw = {
    "output": "```json\n[\n  {\n    \"scene\": \"Scene 1: The Ancient Discovery - Introduction to the Pythagorean Theorem\",\n    \"code\": \"from manimlib import *\\n\\nclass PythagoreanIntro(Scene):\\n    def construct(self):\\n        # Set up cinematic camera\\n        self.camera.frame.save_state()\\n        \\n        # Title sequence with dramatic reveal\\n        title = Text(\\\"The Pythagorean Theorem\\\", font_size=72)\\n        subtitle = Text(\\\"A 2500-Year Journey\\\", font_size=36, color=GREY_B)\\n        subtitle.next_to(title, DOWN, buff=0.5)\\n        \\n        # Ancient Greek pattern background\\n        pattern = VGroup()\\n        for i in range(-8, 9):\\n            for j in range(-5, 6):\\n                if (i + j) % 2 == 0:\\n                    square = Square(side_length=0.3, fill_opacity=0.1, color=GOLD_E)\\n                    square.move_to([i * 0.3, j * 0.3, 0])\\n                    pattern.add(square)\\n        \\n        # Animate entrance\\n        self.play(\\n            FadeIn(pattern, lag_ratio=0.01),\\n            run_time=2\\n        )\\n        self.play(\\n            Write(title),\\n            FadeIn(subtitle, shift=UP),\\n            run_time=3\\n        )\\n        self.wait(2)\\n        \\n        # Fade to theorem statement\\n        self.play(\\n            FadeOut(VGroup(title, subtitle)),\\n            pattern.animate.set_opacity(0.05),\\n            run_time=2\\n        )\\n        \\n        # The famous equation\\n        equation = Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=96)\\n        equation.set_color_by_gradient(BLUE, GREEN)\\n        \\n        # Create right triangle\\n        triangle = Polygon(\\n            [-3, -2, 0], [3, -2, 0], [3, 2, 0],\\n            color=WHITE, stroke_width=4\\n        )\\n        \\n        # Label sides\\n        label_a = Tex(\\\"a\\\", font_size=48, color=BLUE)\\n        label_b = Tex(\\\"b\\\", font_size=48, color=GREEN)\\n        label_c = Tex(\\\"c\\\", font_size=48, color=RED)\\n        \\n        label_a.next_to(triangle.get_edge_center(LEFT), LEFT)\\n        label_b.next_to(triangle.get_edge_center(DOWN), DOWN)\\n        label_c.move_to(triangle.get_center() + [-0.5, -0.5, 0])\\n        \\n        # Right angle indicator\\n        right_angle = Square(side_length=0.4, color=YELLOW)\\n        right_angle.move_to(triangle.get_vertices()[1] + [0.2, 0.2, 0])\\n        \\n        # Cinematic reveal\\n        self.play(\\n            equation.animate.scale(0.6).to_edge(UP),\\n            run_time=2\\n        )\\n        self.play(\\n            Create(triangle),\\n            run_time=2\\n        )\\n        self.play(\\n            FadeIn(right_angle),\\n            Write(label_a),\\n            Write(label_b), \\n            Write(label_c),\\n            run_time=2\\n        )\\n        \\n        # Camera zoom effect\\n        self.play(\\n            self.camera.frame.animate.scale(0.8).move_to(triangle),\\n            run_time=2\\n        )\\n        self.wait(2)\\n        \\n        # Transition text\\n        discovery_text = Text(\\\"But what does this really mean?\\\", font_size=36, color=GREY_A)\\n        discovery_text.to_edge(DOWN)\\n        \\n        self.play(\\n            FadeIn(discovery_text, shift=UP),\\n            run_time=2\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 2: Visual Proof - The Square Construction\",\n    \"code\": \"from manimlib import *\\n\\nclass SquareConstruction(Scene):\\n    def construct(self):\\n        # Create base right triangle\\n        vertices = [[-2, -1.5, 0], [2, -1.5, 0], [2, 1.5, 0]]\\n        triangle = Polygon(*vertices, color=WHITE, stroke_width=3)\\n        \\n        # Calculate side lengths\\n        a = np.linalg.norm(np.array(vertices[2]) - np.array(vertices[1]))\\n        b = np.linalg.norm(np.array(vertices[1]) - np.array(vertices[0]))\\n        c = np.linalg.norm(np.array(vertices[2]) - np.array(vertices[0]))\\n        \\n        # Create squares on each side\\n        # Square on side a (vertical)\\n        square_a = Square(side_length=a, color=BLUE, fill_opacity=0.3)\\n        square_a.move_to(vertices[1] + [a/2 + 0.1, 0, 0])\\n        \\n        # Square on side b (horizontal)\\n        square_b = Square(side_length=b, color=GREEN, fill_opacity=0.3)\\n        square_b.move_to(vertices[0] + [0, -b/2 - 0.1, 0])\\n        \\n        # Square on hypotenuse c\\n        angle = np.arctan2(vertices[2][1] - vertices[0][1], vertices[2][0] - vertices[0][0])\\n        square_c = Square(side_length=c, color=RED, fill_opacity=0.3)\\n        square_c.rotate(angle - PI/2)\\n        mid_point = (np.array(vertices[0]) + np.array(vertices[2])) / 2\\n        offset = np.array([np.sin(angle), -np.cos(angle), 0]) * c/2\\n        square_c.move_to(mid_point + offset * 1.1)\\n        \\n        # Labels for areas\\n        area_a = Tex(r\\\"a^2\\\", font_size=48, color=BLUE)\\n        area_b = Tex(r\\\"b^2\\\", font_size=48, color=GREEN)\\n        area_c = Tex(r\\\"c^2\\\", font_size=48, color=RED)\\n        \\n        area_a.move_to(square_a.get_center())\\n        area_b.move_to(square_b.get_center())\\n        area_c.move_to(square_c.get_center())\\n        \\n        # Title\\n        title = Text(\\\"Geometric Proof\\\", font_size=56)\\n        title.to_edge(UP)\\n        \\n        # Animate construction\\n        self.play(Write(title), run_time=2)\\n        self.play(Create(triangle), run_time=2)\\n        \\n        # Dramatic square reveals\\n        self.play(\\n            GrowFromCenter(square_a),\\n            Write(area_a),\\n            run_time=2\\n        )\\n        self.play(\\n            GrowFromCenter(square_b),\\n            Write(area_b),\\n            run_time=2\\n        )\\n        self.play(\\n            GrowFromCenter(square_c),\\n            Write(area_c),\\n            run_time=2\\n        )\\n        \\n        # Show the equation\\n        equation = Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=64)\\n        equation.to_edge(DOWN)\\n        equation.set_color_by_tex_to_color_map({\\n            \\\"a^2\\\": BLUE,\\n            \\\"b^2\\\": GREEN,\\n            \\\"c^2\\\": RED\\n        })\\n        \\n        # Camera focus on equation\\n        self.play(\\n            Write(equation),\\n            self.camera.frame.animate.shift(DOWN * 0.5),\\n            run_time=3\\n        )\\n        \\n        # Visual emphasis with pulsing\\n        self.play(\\n            square_a.animate.set_fill_opacity(0.6),\\n            square_b.animate.set_fill_opacity(0.6),\\n            run_time=1\\n        )\\n        self.play(\\n            square_a.animate.set_fill_opacity(0.3),\\n            square_b.animate.set_fill_opacity(0.3),\\n            square_c.animate.set_fill_opacity(0.6),\\n            run_time=1\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 3: The Rearrangement Proof\",\n    \"code\": \"from manimlib import *\\n\\nclass RearrangementProof(Scene):\\n    def construct(self):\\n        # Create four identical right triangles\\n        def create_triangle(color=WHITE):\\n            return Polygon(\\n                [0, 0, 0], [3, 0, 0], [3, 4, 0],\\n                color=color, fill_opacity=0.3, stroke_width=2\\n            )\\n        \\n        # Initial configuration - square with hole\\n        triangles_1 = VGroup()\\n        positions = [\\n            (UP * 2 + RIGHT * 2, 0),\\n            (DOWN * 2 + RIGHT * 2, -PI/2),\\n            (DOWN * 2 + LEFT * 2, PI),\\n            (UP * 2 + LEFT * 2, PI/2)\\n        ]\\n        \\n        colors = [BLUE_C, GREEN_C, RED_C, YELLOW_C]\\n        \\n        for i, (pos, angle) in enumerate(positions):\\n            tri = create_triangle(colors[i])\\n            tri.rotate(angle)\\n            tri.move_to(pos)\\n            triangles_1.add(tri)\\n        \\n        # Create the inner square (c²)\\n        inner_square = Square(side_length=5, color=PURPLE, fill_opacity=0.2)\\n        \\n        # Title\\n        title = Text(\\\"The Rearrangement Proof\\\", font_size=48)\\n        title.to_edge(UP)\\n        \\n        # Labels\\n        label_c_squared = Tex(r\\\"c^2\\\", font_size=64, color=PURPLE)\\n        \\n        # Animate initial setup\\n        self.play(Write(title), run_time=2)\\n        self.play(\\n            *[GrowFromCenter(tri) for tri in triangles_1],\\n            run_time=3\\n        )\\n        self.play(\\n            FadeIn(inner_square),\\n            Write(label_c_squared),\\n            run_time=2\\n        )\\n        self.wait(2)\\n        \\n        # Second configuration - two rectangles\\n        triangles_2 = VGroup()\\n        tri_configs = [\\n            (LEFT * 3.5 + UP * 0.5, 0),\\n            (LEFT * 0.5 + UP * 0.5, -PI/2),\\n            (RIGHT * 0.5 + DOWN * 0.5, 0),\\n            (RIGHT * 3.5 + DOWN * 0.5, -PI/2)\\n        ]\\n        \\n        for i, (pos, angle) in enumerate(tri_configs):\\n            tri = create_triangle(colors[i])\\n            tri.rotate(angle)\\n            tri.move_to(pos)\\n            triangles_2.add(tri)\\n        \\n        # Create squares a² and b²\\n        square_a = Square(side_length=3, color=BLUE, fill_opacity=0.2)\\n        square_a.move_to(LEFT * 2 + DOWN * 2)\\n        \\n        square_b = Square(side_length=4, color=GREEN, fill_opacity=0.2)\\n        square_b.move_to(RIGHT * 2 + UP * 2)\\n        \\n        label_a_squared = Tex(r\\\"a^2\\\", font_size=48, color=BLUE)\\n        label_b_squared = Tex(r\\\"b^2\\\", font_size=48, color=GREEN)\\n        \\n        label_a_squared.move_to(square_a)\\n        label_b_squared.move_to(square_b)\\n        \\n        # Dramatic rearrangement\\n        self.play(\\n            self.camera.frame.animate.scale(1.3),\\n            run_time=2\\n        )\\n        \\n        # Transform triangles\\n        self.play(\\n            *[Transform(triangles_1[i], triangles_2[i]) for i in range(4)],\\n            FadeOut(inner_square),\\n            FadeOut(label_c_squared),\\n            run_time=3\\n        )\\n        \\n        # Reveal a² and b²\\n        self.play(\\n            FadeIn(square_a),\\n            FadeIn(square_b),\\n            Write(label_a_squared),\\n            Write(label_b_squared),\\n            run_time=3\\n        )\\n        \\n        # Final equation\\n        final_equation = Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=72)\\n        final_equation.to_edge(DOWN)\\n        final_equation.set_color_by_gradient(BLUE, GREEN, RED)\\n        \\n        self.play(\\n            Write(final_equation),\\n            run_time=3\\n        )\\n        self.wait(3)\"\n  },\n  {\n    \"scene\": \"Scene 4: Algebraic Derivation\",\n    \"code\": \"from manimlib import *\\n\\nclass AlgebraicDerivation(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Algebraic Proof\\\", font_size=56, color=BLUE_B)\\n        title.to_edge(UP)\\n        self.play(Write(title), run_time=2)\\n        \\n        # Create coordinate system\\n        axes = Axes(\\n            x_range=[-1, 6],\\n            y_range=[-1, 5],\\n            x_length=7,\\n            y_length=6,\\n            axis_config={\\\"include_tip\\\": True}\\n        )\\n        axes.to_edge(LEFT, buff=1)\\n        \\n        # Triangle vertices\\n        A = axes.c2p(0, 0)\\n        B = axes.c2p(4, 0)\\n        C = axes.c2p(4, 3)\\n        \\n        # Create triangle\\n        triangle = Polygon(A, B, C, color=WHITE, stroke_width=3)\\n        \\n        # Labels\\n        label_A = Tex(\\\"A\\\", font_size=36).next_to(A, DL, buff=0.1)\\n        label_B = Tex(\\\"B\\\", font_size=36).next_to(B, DR, buff=0.1)\\n        label_C = Tex(\\\"C\\\", font_size=36).next_to(C, UR, buff=0.1)\\n        \\n        # Animate coordinate system\\n        self.play(\\n            Create(axes),\\n            run_time=2\\n        )\\n        self.play(\\n            Create(triangle),\\n            Write(label_A),\\n            Write(label_B),\\n            Write(label_C),\\n            run_time=2\\n        )\\n        \\n        # Coordinate labels\\n        coord_A = Tex(r\\\"(0, 0)\\\", font_size=24, color=GREY_B).next_to(label_A, DOWN, buff=0.1)\\n        coord_B = Tex(r\\\"(a, 0)\\\", font_size=24, color=GREY_B).next_to(label_B, DOWN, buff=0.1)\\n        coord_C = Tex(r\\\"(a, b)\\\", font_size=24, color=GREY_B).next_to(label_C, RIGHT, buff=0.1)\\n        \\n        self.play(\\n            Write(coord_A),\\n            Write(coord_B),\\n            Write(coord_C),\\n            run_time=2\\n        )\\n        \\n        # Distance formula explanation\\n        explanation = VGroup(\\n            Tex(r\\\"\\\\text{Distance formula:}\\\", font_size=36),\\n            Tex(r\\\"d = \\\\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\\", font_size=32)\\n        ).arrange(DOWN, buff=0.5)\\n        explanation.to_edge(RIGHT, buff=1).shift(UP * 2)\\n        \\n        self.play(\\n            FadeIn(explanation, shift=LEFT),\\n            run_time=2\\n        )\\n        \\n        # Calculate distances\\n        calc_group = VGroup(\\n            Tex(r\\\"AB = |a - 0| = a\\\", font_size=28, color=BLUE),\\n            Tex(r\\\"BC = |b - 0| = b\\\", font_size=28, color=GREEN),\\n            Tex(r\\\"AC = \\\\sqrt{(a-0)^2 + (b-0)^2}\\\", font_size=28, color=RED),\\n            Tex(r\\\"AC = \\\\sqrt{a^2 + b^2}\\\", font_size=28, color=RED)\\n        ).arrange(DOWN, buff=0.3)\\n        calc_group.next_to(explanation, DOWN, buff=0.8)\\n        \\n        # Animate calculations\\n        for i, calc in enumerate(calc_group):\\n            self.play(Write(calc), run_time=1.5)\\n            self.wait(0.5)\\n        \\n        # Highlight the result\\n        box = SurroundingRectangle(calc_group[-1], color=YELLOW, buff=0.1)\\n        self.play(Create(box), run_time=1)\\n        \\n        # Final transformation\\n        final_form = Tex(r\\\"c = \\\\sqrt{a^2 + b^2}\\\", font_size=48)\\n        final_form.move_to(calc_group)\\n        \\n        theorem = Tex(r\\\"c^2 = a^2 + b^2\\\", font_size=64, color=GOLD)\\n        theorem.to_edge(DOWN, buff=1)\\n        \\n        self.play(\\n            Transform(calc_group, final_form),\\n            FadeOut(box),\\n            run_time=2\\n        )\\n        self.play(\\n            Write(theorem),\\n            run_time=2\\n        )\\n        \\n        # Emphasis animation\\n        self.play(\\n            theorem.animate.scale(1.2),\\n            run_time=0.5\\n        )\\n        self.play(\\n            theorem.animate.scale(1/1.2),\\n            run_time=0.5\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 5: Similar Triangles Proof\",\n    \"code\": \"from manimlib import *\\n\\nclass SimilarTrianglesProof(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Proof by Similar Triangles\\\", font_size=48)\\n        title.to_edge(UP)\\n        self.play(Write(title), run_time=2)\\n        \\n        # Main triangle ABC\\n        A = np.array([-3, -2, 0])\\n        B = np.array([3, -2, 0])\\n        C = np.array([1.5, 2, 0])\\n        \\n        main_triangle = Polygon(A, B, C, color=WHITE, stroke_width=4)\\n        \\n        # Calculate altitude point\\n        # Point D on AB such that CD ⟂ AB\\n        t = ((C[0] - A[0]) * (B[0] - A[0]) + (C[1] - A[1]) * (B[1] - A[1])) / np.linalg.norm(B - A)**2\\n        D = A + t * (B - A)\\n        \\n        # Altitude\\n        altitude = Line(C, D, color=YELLOW, stroke_width=3)\\n        \\n        # Right angle marker\\n        right_angle = Square(side_length=0.3, color=YELLOW, fill_opacity=0.3)\\n        right_angle.move_to(D + np.array([0, 0.15, 0]))\\n        \\n        # Labels\\n        label_A = Tex(\\\"A\\\", font_size=36).next_to(A, DL, buff=0.1)\\n        label_B = Tex(\\\"B\\\", font_size=36).next_to(B, DR, buff=0.1)\\n        label_C = Tex(\\\"C\\\", font_size=36).next_to(C, UP, buff=0.1)\\n        label_D = Tex(\\\"D\\\", font_size=36).next_to(D, DOWN, buff=0.1)\\n        \\n        # Animate main triangle\\n        self.play(Create(main_triangle), run_time=2)\\n        self.play(\\n            Write(label_A),\\n            Write(label_B),\\n            Write(label_C),\\n            run_time=2\\n        )\\n        \\n        # Draw altitude\\n        self.play(\\n            Create(altitude),\\n            Write(label_D),\\n            FadeIn(right_angle),\\n            run_time=2\\n        )\\n        \\n        # Highlight similar triangles\\n        triangle_ACD = Polygon(A, C, D, color=BLUE, fill_opacity=0.3, stroke_width=3)\\n        triangle_CBD = Polygon(C, B, D, color=GREEN, fill_opacity=0.3, stroke_width=3)\\n        triangle_ABC = Polygon(A, B, C, color=RED, fill_opacity=0.2, stroke_width=3)\\n        \\n        # Show similar triangles\\n        similar_text = Text(\\\"Three Similar Triangles\\\", font_size=36, color=GREY_B)\\n        similar_text.next_to(main_triangle, DOWN, buff=1)\\n        \\n        self.play(\\n            Write(similar_text),\\n            run_time=2\\n        )\\n        \\n        # Highlight each triangle\\n        self.play(\\n            FadeIn(triangle_ACD),\\n            run_time=1.5\\n        )\\n        self.play(\\n            FadeIn(triangle_CBD),\\n            run_time=1.5\\n        )\\n        self.play(\\n            FadeIn(triangle_ABC),\\n            run_time=1.5\\n        )\\n        \\n        # Similarity ratios\\n        ratios = VGroup(\\n            Tex(r\\\"\\\\frac{AD}{AC} = \\\\frac{AC}{AB}\\\", font_size=32),\\n            Tex(r\\\"\\\\frac{BD}{BC} = \\\\frac{BC}{AB}\\\", font_size=32),\\n        ).arrange(DOWN, buff=0.5)\\n        ratios.to_edge(RIGHT, buff=1).shift(UP)\\n        \\n        self.play(\\n            FadeIn(ratios, shift=LEFT),\\n            run_time=3\\n        )\\n        \\n        # Derive the theorem\\n        derivation = VGroup(\\n            Tex(r\\\"AD \\\\cdot AB = AC^2\\\", font_size=28, color=BLUE),\\n            Tex(r\\\"BD \\\\cdot AB = BC^2\\\", font_size=28, color=GREEN),\\n            Tex(r\\\"(AD + BD) \\\\cdot AB = AC^2 + BC^2\\\", font_size=28),\\n            Tex(r\\\"AB \\\\cdot AB = AC^2 + BC^2\\\", font_size=28),\\n            Tex(r\\\"AB^2 = AC^2 + BC^2\\\", font_size=32, color=GOLD)\\n        ).arrange(DOWN, buff=0.3)\\n        derivation.next_to(ratios, DOWN, buff=0.8)\\n        \\n        # Animate derivation step by step\\n        for i, step in enumerate(derivation):\\n            if i < 2:\\n                self.play(Write(step), run_time=1.5)\\n            else:\\n                self.play(\\n                    Transform(derivation[i-1].copy(), step),\\n                    run_time=2\\n                )\\n            self.wait(0.5)\\n        \\n        # Final emphasis\\n        final_box = SurroundingRectangle(derivation[-1], color=YELLOW, buff=0.15)\\n        self.play(Create(final_box), run_time=1)\\n        \\n        # Label correspondence\\n        final_label = Tex(r\\\"c^2 = a^2 + b^2\\\", font_size=48)\\n        final_label.to_edge(DOWN)\\n        \\n        self.play(\\n            Write(final_label),\\n            run_time=2\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 6: Real-World Applications\",\n    \"code\": \"from manimlib import *\\n\\nclass RealWorldApplications(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Real-World Applications\\\", font_size=56, color=BLUE_B)\\n        title.to_edge(UP)\\n        self.play(Write(title), run_time=2)\\n        \\n        # Application 1: Construction/Architecture\\n        subtitle1 = Text(\\\"Architecture & Construction\\\", font_size=36, color=GREY_A)\\n        subtitle1.next_to(title, DOWN, buff=0.5)\\n        \\n        # Create a building frame\\n        building_base = Rectangle(width=4, height=0.3, fill_opacity=0.8, color=GREY_B)\\n        building_base.to_edge(DOWN, buff=1)\\n        \\n        # Vertical supports\\n        left_support = Line(building_base.get_left(), building_base.get_left() + UP * 4, stroke_width=8, color=GREY_C)\\n        right_support = Line(building_base.get_right(), building_base.get_right() + UP * 4, stroke_width=8, color=GREY_C)\\n        \\n        # Diagonal brace\\n        brace = Line(left_support.get_top(), right_support.get_bottom(), stroke_width=6, color=RED)\\n        \\n        # Measurements\\n        height_label = Tex(\\\"4m\\\", font_size=28, color=BLUE).next_to(left_support, LEFT)\\n        width_label = Tex(\\\"3m\\\", font_size=28, color=GREEN).next_to(building_base, DOWN)\\n        brace_label = Tex(\\\"?\\\", font_size=32, color=RED).move_to(brace.get_center() + UR * 0.3)\\n        \\n        # Animate construction\\n        self.play(Write(subtitle1), run_time=1.5)\\n        self.play(\\n            FadeIn(building_base),\\n            Create(left_support),\\n            Create(right_support),\\n            run_time=2\\n        )\\n        self.play(\\n            Write(height_label),\\n            Write(width_label),\\n            run_time=1.5\\n        )\\n        self.play(\\n            Create(brace),\\n            Write(brace_label),\\n            run_time=2\\n        )\\n        \\n        # Calculate diagonal\\n        calculation = Tex(r\\\"d = \\\\sqrt{3^2 + 4^2} = \\\\sqrt{9 + 16} = \\\\sqrt{25} = 5m\\\", font_size=32)\\n        calculation.next_to(building_base, UP, buff=2)\\n        \\n        self.play(Write(calculation), run_time=3)\\n        self.play(\\n            Transform(brace_label, Tex(\\\"5m\\\", font_size=32, color=RED).move_to(brace_label)),\\n            run_time=1\\n        )\\n        self.wait(2)\\n        \\n        # Transition to next application\\n        self.play(\\n            FadeOut(VGroup(subtitle1, building_base, left_support, right_support, brace,\\n                         height_label, width_label, brace_label, calculation)),\\n            run_time=2\\n        )\\n        \\n        # Application 2: Navigation/GPS\\n        subtitle2 = Text(\\\"Navigation & Distance\\\", font_size=36, color=GREY_A)\\n        subtitle2.next_to(title, DOWN, buff=0.5)\\n        \\n        # Create coordinate grid\\n        grid = NumberPlane(\\n            x_range=[-5, 5],\\n            y_range=[-4, 4],\\n            x_length=8,\\n            y_length=6,\\n            background_line_style={\\n                \\\"stroke_color\\\": GREY_E,\\n                \\\"stroke_width\\\": 1,\\n                \\\"stroke_opacity\\\": 0.5\\n            }\\n        )\\n        \\n        # Points\\n        point_A = Dot(grid.c2p(-3, -2), color=BLUE, radius=0.15)\\n        point_B = Dot(grid.c2p(2, 2), color=GREEN, radius=0.15)\\n        \\n        label_A = Text(\\\"Start\\\", font_size=24).next_to(point_A, DOWN)\\n        label_B = Text(\\\"Destination\\\", font_size=24).next_to(point_B, UP)\\n        \\n        # Path lines\\n        horizontal_path = DashedLine(point_A.get_center(), grid.c2p(2, -2), color=BLUE, stroke_width=3)\\n        vertical_path = DashedLine(grid.c2p(2, -2), point_B.get_center(), color=GREEN, stroke_width=3)\\n        direct_path = Line(point_A.get_center(), point_B.get_center(), color=RED, stroke_width=4)\\n        \\n        # Distance labels\\n        h_dist = Tex(\\\"5 km\\\", font_size=24, color=BLUE).next_to(horizontal_path, DOWN)\\n        v_dist = Tex(\\\"4 km\\\", font_size=24, color=GREEN).next_to(vertical_path, RIGHT)\\n        \\n        # Animate navigation\\n        self.play(Write(subtitle2), run_time=1.5)\\n        self.play(FadeIn(grid), run_time=2)\\n        self.play(\\n            FadeIn(point_A),\\n            FadeIn(point_B),\\n            Write(label_A),\\n            Write(label_B),\\n            run_time=2\\n        )\\n        \\n        # Show grid movement\\n        self.play(\\n            Create(horizontal_path),\\n            Write(h_dist),\\n            run_time=1.5\\n        )\\n        self.play(\\n            Create(vertical_path),\\n            Write(v_dist),\\n            run_time=1.5\\n        )\\n        \\n        # Direct path\\n        direct_calc = Tex(r\\\"d = \\\\sqrt{5^2 + 4^2} = \\\\sqrt{41} \\\\approx 6.4 km\\\", font_size=28)\\n        direct_calc.to_edge(DOWN, buff=1)\\n        \\n        self.play(\\n            Create(direct_path),\\n            Write(direct_calc),\\n            run_time=3\\n        )\\n        \\n        # Show savings\\n        savings = Text(\\\"Saves 2.6 km!\\\", font_size=32, color=YELLOW)\\n        savings.next_to(direct_calc, DOWN)\\n        \\n        self.play(\\n            Write(savings),\\n            direct_path.animate.set_stroke(width=6),\\n            run_time=2\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 7: 3D Extension - Space Diagonal\",\n    \"code\": \"from manimlib import *\\n\\nclass SpaceDiagonal3D(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Extension to 3D Space\\\", font_size=48)\\n        title.to_edge(UP)\\n        self.play(Write(title), run_time=2)\\n        \\n        # Create 3D axes\\n        axes = ThreeDAxes(\\n            x_range=[-1, 5],\\n            y_range=[-1, 5],\\n            z_range=[-1, 5],\\n            x_length=6,\\n            y_length=6,\\n            z_length=6\\n        )\\n        \\n        # Camera setup\\n        self.camera.frame.reorient(phi=70 * DEGREES, theta=-45 * DEGREES)\\n        self.camera.frame.move_to([0, 0, 2])\\n        \\n        # Create rectangular box\\n        vertices = [\\n            [0, 0, 0], [3, 0, 0], [3, 4, 0], [0, 4, 0],  # Bottom face\\n            [0, 0, 2], [3, 0, 2], [3, 4, 2], [0, 4, 2]   # Top face\\n        ]\\n        \\n        # Convert to 3D points\\n        vertices_3d = [axes.c2p(*v) for v in vertices]\\n        \\n        # Create edges\\n        edges = VGroup()\\n        edge_pairs = [\\n            (0, 1), (1, 2), (2, 3), (3, 0),  # Bottom face\\n            (4, 5), (5, 6), (6, 7), (7, 4),  # Top face\\n            (0, 4), (1, 5), (2, 6), (3, 7)   # Vertical edges\\n        ]\\n        \\n        for i, j in edge_pairs:\\n            edge = Line3D(vertices_3d[i], vertices_3d[j], color=GREY_B, stroke_width=3)\\n            edges.add(edge)\\n        \\n        # Space diagonal\\n        diagonal = Line3D(vertices_3d[0], vertices_3d[6], color=RED, stroke_width=6)\\n        \\n        # Dimension labels\\n        label_a = Tex(\\\"a = 3\\\", font_size=28, color=BLUE)\\n        label_b = Tex(\\\"b = 4\\\", font_size=28, color=GREEN)\\n        label_c = Tex(\\\"c = 2\\\", font_size=28, color=YELLOW)\\n        \\n        label_a.next_to(Line(vertices_3d[0], vertices_3d[1]).get_center(), DOWN)\\n        label_b.next_to(Line(vertices_3d[1], vertices_3d[2]).get_center(), RIGHT)\\n        label_c.next_to(Line(vertices_3d[0], vertices_3d[4]).get_center(), LEFT)\\n        \\n        # Animate construction\\n        self.play(Create(axes), run_time=2)\\n        self.play(\\n            Create(edges),\\n            run_time=3\\n        )\\n        \\n        # Animate camera rotation\\n        self.begin_ambient_camera_rotation(rate=0.2)\\n        self.wait(2)\\n        \\n        # Add labels\\n        self.play(\\n            Write(label_a),\\n            Write(label_b),\\n            Write(label_c),\\n            run_time=2\\n        )\\n        \\n        # Show diagonal\\n        self.play(\\n            Create(diagonal),\\n            run_time=2\\n        )\\n        \\n        # Stop rotation for calculation\\n        self.stop_ambient_camera_rotation()\\n        \\n        # 3D Pythagorean theorem\\n        formula_3d = Tex(r\\\"d = \\\\sqrt{a^2 + b^2 + c^2}\\\", font_size=36)\\n        calculation = Tex(r\\\"d = \\\\sqrt{3^2 + 4^2 + 2^2} = \\\\sqrt{9 + 16 + 4} = \\\\sqrt{29}\\\", font_size=32)\\n        result = Tex(r\\\"d \\\\approx 5.39\\\", font_size=36, color=RED)\\n        \\n        formula_group = VGroup(formula_3d, calculation, result).arrange(DOWN, buff=0.3)\\n        formula_group.to_edge(DOWN, buff=1)\\n        \\n        # Face diagonal first\\n        face_diagonal = Line3D(vertices_3d[0], vertices_3d[2], color=PURPLE, stroke_width=4)\\n        \\n        self.play(\\n            Create(face_diagonal),\\n            run_time=2\\n        )\\n        \\n        face_calc = Tex(r\\\"\\\\text{Face diagonal: } \\\\sqrt{3^2 + 4^2} = 5\\\", font_size=28, color=PURPLE)\\n        face_calc.next_to(formula_group, UP, buff=0.5)\\n        \\n        self.play(Write(face_calc), run_time=2)\\n        \\n        # Show full calculation\\n        self.play(\\n            Write(formula_3d),\\n            run_time=2\\n        )\\n        self.play(\\n            Write(calculation),\\n            run_time=3\\n        )\\n        self.play(\\n            Write(result),\\n            diagonal.animate.set_stroke(width=8),\\n            run_time=2\\n        )\\n        \\n        # Final camera movement\\n        self.play(\\n            self.camera.frame.animate.reorient(phi=45 * DEGREES, theta=-30 * DEGREES).scale(1.2),\\n            run_time=3\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 8: Pythagorean Triples\",\n    \"code\": \"from manimlib import *\\n\\nclass PythagoreanTriples(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Pythagorean Triples\\\", font_size=56)\\n        subtitle = Text(\\\"Integer Solutions to a² + b² = c²\\\", font_size=32, color=GREY_B)\\n        title_group = VGroup(title, subtitle).arrange(DOWN, buff=0.3)\\n        title_group.to_edge(UP)\\n        \\n        self.play(\\n            Write(title),\\n            FadeIn(subtitle, shift=UP),\\n            run_time=3\\n        )\\n        \\n        # Famous triples\\n        triples = [\\n            (3, 4, 5),\\n            (5, 12, 13),\\n            (8, 15, 17),\\n            (7, 24, 25)\\n        ]\\n        \\n        triple_texts = VGroup()\\n        for i, (a, b, c) in enumerate(triples):\\n            text = Tex(f\\\"({a}, {b}, {c})\\\", font_size=36)\\n            verification = Tex(f\\\"{a}^2 + {b}^2 = {a*a} + {b*b} = {c*c} = {c}^2\\\", font_size=28, color=GREY_A)\\n            \\n            triple_group = VGroup(text, verification).arrange(RIGHT, buff=1)\\n            triple_texts.add(triple_group)\\n        \\n        triple_texts.arrange(DOWN, buff=0.5)\\n        triple_texts.move_to(ORIGIN)\\n        \\n        # Animate each triple\\n        for i, triple_group in enumerate(triple_texts):\\n            self.play(\\n                FadeIn(triple_group[0], shift=RIGHT),\\n                run_time=1\\n            )\\n            self.play(\\n                Write(triple_group[1]),\\n                run_time=2\\n            )\\n            self.wait(0.5)\\n        \\n        self.wait(1)\\n        \\n        # Transition to visualization\\n        self.play(\\n            FadeOut(triple_texts),\\n            run_time=2\\n        )\\n        \\n        # Visual representation of 3-4-5 triangle\\n        scale = 0.8\\n        triangle_345 = Polygon(\\n            [-2 * scale, -1.5 * scale, 0],\\n            [2 * scale, -1.5 * scale, 0],\\n            [2 * scale, 1 * scale, 0],\\n            color=WHITE, stroke_width=4\\n        )\\n        \\n        # Squares on sides\\n        square_3 = Square(side_length=3 * scale, color=BLUE, fill_opacity=0.3)\\n        square_4 = Square(side_length=4 * scale, color=GREEN, fill_opacity=0.3)\\n        square_5 = Square(side_length=5 * scale, color=RED, fill_opacity=0.3)\\n        \\n        # Position squares\\n        square_3.next_to(triangle_345.get_edge_center(RIGHT), RIGHT, buff=0)\\n        square_4.next_to(triangle_345.get_edge_center(DOWN), DOWN, buff=0)\\n        square_5.rotate(-np.arctan(3/4))\\n        square_5.move_to(triangle_345.get_vertices()[0] + \\n                        np.array([-2.5 * scale * np.cos(np.arctan(3/4)), \\n                                 2.5 * scale * np.sin(np.arctan(3/4)), 0]))\\n        \\n        # Grid dots for area\\n        def create_grid_dots(square, n):\\n            dots = VGroup()\\n            side = square.get_width()\\n            start = square.get_corner(DL)\\n            for i in range(n):\\n                for j in range(n):\\n                    dot = Dot(\\n                        start + RIGHT * (i + 0.5) * side/n + UP * (j + 0.5) * side/n,\\n                        radius=0.05,\\n                        color=square.get_color()\\n                    )\\n                    dots.add(dot)\\n            return dots\\n        \\n        dots_3 = create_grid_dots(square_3, 3)\\n        dots_4 = create_grid_dots(square_4, 4)\\n        dots_5 = create_grid_dots(square_5, 5)\\n        \\n        # Animate triangle and squares\\n        self.play(Create(triangle_345), run_time=2)\\n        self.play(\\n            GrowFromCenter(square_3),\\n            GrowFromCenter(square_4),\\n            GrowFromCenter(square_5),\\n            run_time=3\\n        )\\n        \\n        # Show area counting\\n        count_text = Text(\\\"Counting unit squares:\\\", font_size=32)\\n        count_text.to_edge(DOWN, buff=2)\\n        \\n        self.play(Write(count_text), run_time=1)\\n        \\n        # Animate dots\\n        self.play(\\n            FadeIn(dots_3, lag_ratio=0.05),\\n            FadeIn(dots_4, lag_ratio=0.05),\\n            FadeIn(dots_5, lag_ratio=0.05),\\n            run_time=3\\n        )\\n        \\n        # Area labels\\n        area_3 = Tex(\\\"9\\\", font_size=48, color=BLUE).move_to(square_3)\\n        area_4 = Tex(\\\"16\\\", font_size=48, color=GREEN).move_to(square_4)\\n        area_5 = Tex(\\\"25\\\", font_size=48, color=RED).move_to(square_5)\\n        \\n        self.play(\\n            Write(area_3),\\n            Write(area_4),\\n            Write(area_5),\\n            run_time=2\\n        )\\n        \\n        # Verification\\n        verification = Tex(\\\"9 + 16 = 25 \\\\checkmark\\\", font_size=48, color=YELLOW)\\n        verification.next_to(count_text, DOWN)\\n        \\n        self.play(\\n            Write(verification),\\n            run_time=2\\n        )\\n        \\n        # Formula for generating triples\\n        self.play(\\n            FadeOut(VGroup(triangle_345, square_3, square_4, square_5,\\n                         dots_3, dots_4, dots_5, area_3, area_4, area_5,\\n                         count_text, verification)),\\n            run_time=2\\n        )\\n        \\n        # Euclid's formula\\n        formula_title = Text(\\\"Euclid's Formula for Pythagorean Triples\\\", font_size=40)\\n        formula_title.to_edge(UP, buff=1.5)\\n        \\n        formula = VGroup(\\n            Tex(r\\\"\\\\text{For any integers } m > n > 0:\\\", font_size=32),\\n            Tex(r\\\"a = m^2 - n^2\\\", font_size=36, color=BLUE),\\n            Tex(r\\\"b = 2mn\\\", font_size=36, color=GREEN),\\n            Tex(r\\\"c = m^2 + n^2\\\", font_size=36, color=RED)\\n        ).arrange(DOWN, buff=0.4)\\n        formula.move_to(ORIGIN)\\n        \\n        self.play(\\n            Write(formula_title),\\n            run_time=2\\n        )\\n        self.play(\\n            Write(formula),\\n            run_time=4\\n        )\\n        \\n        # Example\\n        example = VGroup(\\n            Tex(r\\\"\\\\text{Example: } m = 2, n = 1\\\", font_size=28),\\n            Tex(r\\\"a = 4 - 1 = 3\\\", font_size=28, color=BLUE),\\n            Tex(r\\\"b = 2 \\\\cdot 2 \\\\cdot 1 = 4\\\", font_size=28, color=GREEN),\\n            Tex(r\\\"c = 4 + 1 = 5\\\", font_size=28, color=RED)\\n        ).arrange(DOWN, buff=0.2)\\n        example.to_edge(DOWN, buff=1)\\n        \\n        self.play(\\n            Write(example),\\n            run_time=3\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 9: Non-Euclidean Geometry\",\n    \"code\": \"from manimlib import *\\n\\nclass NonEuclideanPythagorean(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"Beyond Euclidean Space\\\", font_size=48)\\n        subtitle = Text(\\\"The Pythagorean Theorem in Curved Geometry\\\", font_size=28, color=GREY_B)\\n        title_group = VGroup(title, subtitle).arrange(DOWN, buff=0.3)\\n        title_group.to_edge(UP)\\n        \\n        self.play(\\n            Write(title),\\n            FadeIn(subtitle, shift=UP),\\n            run_time=3\\n        )\\n        \\n        # Create three surfaces side by side\\n        # Flat (Euclidean)\\n        flat_surface = Rectangle(width=3, height=3, color=BLUE_B, fill_opacity=0.2)\\n        flat_surface.shift(LEFT * 4)\\n        flat_label = Text(\\\"Flat Space\\\\n(Euclidean)\\\", font_size=24).next_to(flat_surface, DOWN)\\n        \\n        # Create triangle on flat surface\\n        flat_tri = Polygon(\\n            flat_surface.get_center() + [-0.8, -0.8, 0],\\n            flat_surface.get_center() + [0.8, -0.8, 0],\\n            flat_surface.get_center() + [0.8, 0.6, 0],\\n            color=WHITE, stroke_width=3\\n        )\\n        \\n        # Spherical (positive curvature)\\n        sphere_surface = Circle(radius=1.5, color=GREEN_B, fill_opacity=0.2)\\n        sphere_label = Text(\\\"Positive Curvature\\\\n(Spherical)\\\", font_size=24).next_to(sphere_surface, DOWN)\\n        \\n        # Create curved triangle on sphere\\n        sphere_tri = VMobject(color=WHITE, stroke_width=3)\\n        sphere_tri.set_points_as_corners([\\n            sphere_surface.get_center() + [-0.8, -0.6, 0],\\n            sphere_surface.get_center() + [0.8, -0.6, 0],\\n            sphere_surface.get_center() + [0.6, 0.8, 0],\\n            sphere_surface.get_center() + [-0.8, -0.6, 0]\\n        ])\\n        sphere_tri.make_smooth()\\n        \\n        # Hyperbolic (negative curvature)\\n        hyperbolic_surface = VMobject(color=RED_B, fill_opacity=0.2)\\n        hyperbolic_surface.set_points_as_corners([\\n            RIGHT * 4 + [-1.5, -1.5, 0],\\n            RIGHT * 4 + [1.5, -1.5, 0],\\n            RIGHT * 4 + [1.8, 0, 0],\\n            RIGHT * 4 + [1.5, 1.5, 0],\\n            RIGHT * 4 + [-1.5, 1.5, 0],\\n            RIGHT * 4 + [-1.8, 0, 0],\\n            RIGHT * 4 + [-1.5, -1.5, 0]\\n        ])\\n        hyperbolic_surface.make_smooth()\\n        hyperbolic_label = Text(\\\"Negative Curvature\\\\n(Hyperbolic)\\\", font_size=24).next_to(hyperbolic_surface, DOWN)\\n        \\n        # Create triangle on hyperbolic surface\\n        hyp_tri = VMobject(color=WHITE, stroke_width=3)\\n        hyp_tri.set_points_as_corners([\\n            RIGHT * 4 + [-0.6, -0.8, 0],\\n            RIGHT * 4 + [0.6, -0.8, 0],\\n            RIGHT * 4 + [0.5, 0.6, 0],\\n            RIGHT * 4 + [-0.6, -0.8, 0]\\n        ])\\n        hyp_tri.make_smooth()\\n        \\n        # Animate surfaces\\n        self.play(\\n            FadeIn(flat_surface),\\n            FadeIn(sphere_surface),\\n            FadeIn(hyperbolic_surface),\\n            Write(flat_label),\\n            Write(sphere_label),\\n            Write(hyperbolic_label),\\n            run_time=3\\n        )\\n        \\n        # Draw triangles\\n        self.play(\\n            Create(flat_tri),\\n            Create(sphere_tri),\\n            Create(hyp_tri),\\n            run_time=2\\n        )\\n        \\n        # Pythagorean theorem modifications\\n        flat_eq = Tex(r\\\"c^2 = a^2 + b^2\\\", font_size=28, color=BLUE)\\n        flat_eq.next_to(flat_label, DOWN, buff=0.3)\\n        \\n        sphere_eq = Tex(r\\\"c^2 < a^2 + b^2\\\", font_size=28, color=GREEN)\\n        sphere_eq.next_to(sphere_label, DOWN, buff=0.3)\\n        \\n        hyp_eq = Tex(r\\\"c^2 > a^2 + b^2\\\", font_size=28, color=RED)\\n        hyp_eq.next_to(hyperbolic_label, DOWN, buff=0.3)\\n        \\n        self.play(\\n            Write(flat_eq),\\n            Write(sphere_eq),\\n            Write(hyp_eq),\\n            run_time=3\\n        )\\n        \\n        # Transition to sphere demonstration\\n        self.play(\\n            FadeOut(VGroup(flat_surface, flat_tri, flat_label, flat_eq,\\n                         hyperbolic_surface, hyp_tri, hyperbolic_label, hyp_eq)),\\n            sphere_surface.animate.scale(2).move_to(ORIGIN),\\n            sphere_tri.animate.scale(2).move_to(ORIGIN),\\n            sphere_label.animate.next_to(ORIGIN, DOWN, buff=2),\\n            sphere_eq.animate.next_to(ORIGIN, DOWN, buff=2.5),\\n            run_time=2\\n        )\\n        \\n        # Add geodesics\\n        geodesic_text = Text(\\\"On a sphere, 'straight lines' are great circles\\\", font_size=32, color=GREY_A)\\n        geodesic_text.to_edge(UP, buff=1.5)\\n        \\n        self.play(Write(geodesic_text), run_time=2)\\n        \\n        # Show angle sum > 180°\\n        angle_sum = Tex(r\\\"\\\\text{Angle sum} > 180°\\\", font_size=36, color=YELLOW)\\n        angle_sum.next_to(sphere_eq, DOWN, buff=0.5)\\n        \\n        # Mark angles\\n        angle_markers = VGroup()\\n        for vertex in sphere_tri.get_vertices()[:3]:\\n            arc = Arc(radius=0.3, angle=PI/3, color=YELLOW)\\n            arc.move_to(vertex)\\n            angle_markers.add(arc)\\n        \\n        self.play(\\n            Create(angle_markers),\\n            Write(angle_sum),\\n            run_time=3\\n        )\\n        \\n        # Final insight\\n        insight = Text(\\n            \\\"The Pythagorean theorem reveals\\\\nthe curvature of space itself!\\\",\\n            font_size=36,\\n            color=GOLD\\n        )\\n        insight.to_edge(DOWN, buff=0.5)\\n        \\n        self.play(\\n            Write(insight),\\n            sphere_surface.animate.set_fill_opacity(0.4),\\n            run_time=3\\n        )\\n        self.wait(2)\"\n  },\n  {\n    \"scene\": \"Scene 10: Historical Timeline and Impact\",\n    \"code\": \"from manimlib import *\\n\\nclass HistoricalTimeline(Scene):\\n    def construct(self):\\n        # Title\\n        title = Text(\\\"The Pythagorean Legacy\\\", font_size=56)\\n        subtitle = Text(\\\"2500 Years of Mathematical Impact\\\", font_size=32, color=GREY_B)\\n        title_group = VGroup(title, subtitle).arrange(DOWN, buff=0.3)\\n        title_group.to_edge(UP)\\n        \\n        self.play(\\n            Write(title),\\n            FadeIn(subtitle, shift=UP),\\n            run_time=3\\n        )\\n        \\n        # Timeline\\n        timeline = Line(LEFT * 6, RIGHT * 6, stroke_width=4, color=GREY_C)\\n        timeline.shift(UP * 0.5)\\n        \\n        # Time markers\\n        dates = [-500, 300, 1600, 1900, 2024]\\n        events = [\\n            \\\"Pythagoras\\\\n~500 BCE\\\",\\n            \\\"Euclid's Elements\\\\n~300 BCE\\\",\\n            \\\"Descartes\\\\nCoordinate Geometry\\\\n1637 CE\\\",\\n            \\\"Einstein\\\\nSpacetime\\\\n1905 CE\\\",\\n            \\\"Modern Applications\\\\n2024 CE\\\"\\n        ]\\n        \\n        markers = VGroup()\\n        labels = VGroup()\\n        \\n        for date, event in zip(dates, events):\\n            # Normalize position\\n            x_pos = (date + 500) / 2524 * 12 - 6\\n            \\n            # Create marker\\n            marker = Line(UP * 0.2, DOWN * 0.2, stroke_width=3, color=WHITE)\\n            marker.move_to([x_pos, 0.5, 0])\\n            markers.add(marker)\\n            \\n            # Create label\\n            label = Text(event, font_size=20, color=GREY_A)\\n            label.next_to(marker, DOWN, buff=0.3)\\n            labels.add(label)\\n        \\n        # Animate timeline\\n        self.play(Create(timeline), run_time=2)\\n        self.play(\\n            *[Create(marker) for marker in markers],\\n            run_time=2\\n        )\\n        self.play(\\n            *[FadeIn(label, shift=UP) for label in labels],\\n            run_time=3\\n        )\\n        \\n        # Highlight key developments\\n        self.wait(1)\\n        \\n        # Pythagoras highlight\\n        pythagoras_rect = SurroundingRectangle(labels[0], color=GOLD, buff=0.1)\\n        pyth_detail = VGroup(\\n            Text(\\\"The Original Discovery\\\", font_size=28, color=GOLD),\\n            Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=36)\\n        ).arrange(DOWN, buff=0.3)\\n        pyth_detail.to_edge(DOWN, buff=1)\\n        \\n        self.play(\\n            Create(pythagoras_rect),\\n            FadeIn(pyth_detail, shift=UP),\\n            run_time=2\\n        )\\n        self.wait(1)\\n        self.play(\\n            FadeOut(pythagoras_rect),\\n            FadeOut(pyth_detail),\\n            run_time=1\\n        )\\n        \\n        # Euclid highlight\\n        euclid_rect = SurroundingRectangle(labels[1], color=BLUE, buff=0.1)\\n        euclid_detail = VGroup(\\n            Text(\\\"Rigorous Proof\\\", font_size=28, color=BLUE),\\n            Text(\\\"47th Proposition, Book I\\\", font_size=24, color=GREY_B)\\n        ).arrange(DOWN, buff=0.3)\\n        euclid_detail.to_edge(DOWN, buff=1)\\n        \\n        self.play(\\n            Create(euclid_rect),\\n            FadeIn(euclid_detail, shift=UP),\\n            run_time=2\\n        )\\n        self.wait(1)\\n        self.play(\\n            FadeOut(euclid_rect),\\n            FadeOut(euclid_detail),\\n            run_time=1\\n        )\\n        \\n        # Modern applications montage\\n        self.play(\\n            FadeOut(VGroup(timeline, markers, labels)),\\n            run_time=2\\n        )\\n        \\n        # Application grid\\n        applications = [\\n            (\\\"Computer Graphics\\\", BLUE, \\\"3D rendering, game engines\\\"),\\n            (\\\"GPS Navigation\\\", GREEN, \\\"Distance calculations\\\"),\\n            (\\\"Architecture\\\", ORANGE, \\\"Structural engineering\\\"),\\n            (\\\"Signal Processing\\\", PURPLE, \\\"Fourier transforms\\\"),\\n            (\\\"Machine Learning\\\", RED, \\\"Euclidean distance metrics\\\"),\\n            (\\\"Quantum Physics\\\", TEAL, \\\"Wave functions\\\")\\n        ]\\n        \\n        app_groups = VGroup()\\n        for i, (title, color, desc) in enumerate(applications):\\n            # Create application box\\n            box = Rectangle(width=3.5, height=1.5, color=color, fill_opacity=0.2)\\n            app_title = Text(title, font_size=24, color=color)\\n            app_desc = Text(desc, font_size=16, color=GREY_B)\\n            \\n            app_group = VGroup(box, app_title, app_desc)\\n            app_title.move_to(box.get_top() + DOWN * 0.3)\\n            app_desc.move_to(box.get_bottom() + UP * 0.3)\\n            \\n            # Position in grid\\n            row = i // 3\\n            col = i % 3\\n            app_group.move_to([col * 4 - 4, -row * 2, 0])\\n            app_groups.add(app_group)\\n        \\n        # Animate applications\\n        self.play(\\n            *[FadeIn(app, scale=0.8) for app in app_groups],\\n            run_time=3\\n        )\\n        \\n        # Pulsing emphasis\\n        for app in app_groups:\\n            self.play(\\n                app[0].animate.set_fill_opacity(0.4),\\n                run_time=0.3\\n            )\\n            self.play(\\n                app[0].animate.set_fill_opacity(0.2),\\n                run_time=0.3\\n            )\\n        \\n        # Final message\\n        final_message = VGroup(\\n            Text(\\\"The Pythagorean Theorem:\\\", font_size=40),\\n            Text(\\\"A cornerstone of human knowledge\\\", font_size=36, color=GOLD)\\n        ).arrange(DOWN, buff=0.4)\\n        final_message.to_edge(DOWN, buff=0.5)\\n        \\n        # Background fade\\n        bg_rect = Rectangle(\\n            width=14, height=2,\\n            fill_opacity=0.8,\\n            fill_color=BLACK,\\n            stroke_width=0\\n        )\\n        bg_rect.move_to(final_message)\\n        \\n        self.play(\\n            FadeIn(bg_rect),\\n            Write(final_message),\\n            run_time=3\\n        )\\n        \\n        # Final equation fade in\\n        final_eq = Tex(r\\\"a^2 + b^2 = c^2\\\", font_size=96)\\n        final_eq.set_color_by_gradient(BLUE, GREEN, RED)\\n        final_eq.move_to(ORIGIN)\\n        \\n        self.play(\\n            FadeOut(app_groups),\\n            FadeOut(bg_rect),\\n            FadeOut(final_message[0]),\\n            Transform(final_message[1], final_eq),\\n            run_time=4\\n        )\\n        self.wait(3)\"\n  }\n]\n```"
}

// Function to robustly parse the LLM output string
function robustParseLLMOutput(rawObj: { output: string }): any[] | null {
  let outputStr = rawObj.output.trim();

  // Step 1: Strip ```json ... ``` or ``` ... ```
  const codeBlockRegex = /^```(?:json)?\s*([\s\S]*?)\s*```$/;
  const match = outputStr.match(codeBlockRegex);
  if (match) {
    outputStr = match[1].trim();
  }

  // Step 2: Try parsing
  try {
    const parsed = JSON.parse(outputStr);
    return parsed;
  } catch (err) {
    console.error('❌ Failed to parse output:', err);
    return null;
  }
}


async function main() {
  const parsedOutput = robustParseLLMOutput(raw);
  if (parsedOutput) {
    const outputPath = path.join(process.cwd(), 'app', 'api', 'output', 'output.json');
    await fs.writeFile(outputPath, JSON.stringify(parsedOutput, null, 2), 'utf-8');
    console.log('✅ Output written to output/output.json');
  } else {
    console.error('❌ Failed to parse LLM output.');
  }
}

main(); 